/*
 * Apache NiFi REST API
 * REST API definition for Apache NiFi web services
 *
 * OpenAPI spec version: 2.4.0
 * Contact: dev@nifi.apache.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.apache.nifi.api.toolkit.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.List;
import org.apache.nifi.api.toolkit.model.GarbageCollectionDTO;
import org.apache.nifi.api.toolkit.model.ResourceClaimDetailsDTO;
import org.apache.nifi.api.toolkit.model.StorageUsageDTO;
import org.apache.nifi.api.toolkit.model.VersionInfoDTO;
/**
 * The System Diagnostics snapshot from the node.
 */
@Schema(description = "The System Diagnostics snapshot from the node.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2025-09-03T13:15:23.252321740+05:30[Asia/Kolkata]")

public class SystemDiagnosticsSnapshotDTO {
  @JsonProperty("availableProcessors")
  private Integer availableProcessors = null;

  @JsonProperty("contentRepositoryStorageUsage")
  private List<StorageUsageDTO> contentRepositoryStorageUsage = null;

  @JsonProperty("daemonThreads")
  private Integer daemonThreads = null;

  @JsonProperty("flowFileRepositoryStorageUsage")
  private StorageUsageDTO flowFileRepositoryStorageUsage = null;

  @JsonProperty("freeHeap")
  private String freeHeap = null;

  @JsonProperty("freeHeapBytes")
  private Long freeHeapBytes = null;

  @JsonProperty("freeNonHeap")
  private String freeNonHeap = null;

  @JsonProperty("freeNonHeapBytes")
  private Long freeNonHeapBytes = null;

  @JsonProperty("garbageCollection")
  private List<GarbageCollectionDTO> garbageCollection = null;

  @JsonProperty("heapUtilization")
  private String heapUtilization = null;

  @JsonProperty("maxHeap")
  private String maxHeap = null;

  @JsonProperty("maxHeapBytes")
  private Long maxHeapBytes = null;

  @JsonProperty("maxNonHeap")
  private String maxNonHeap = null;

  @JsonProperty("maxNonHeapBytes")
  private Long maxNonHeapBytes = null;

  @JsonProperty("nonHeapUtilization")
  private String nonHeapUtilization = null;

  @JsonProperty("processorLoadAverage")
  private Double processorLoadAverage = null;

  @JsonProperty("provenanceRepositoryStorageUsage")
  private List<StorageUsageDTO> provenanceRepositoryStorageUsage = null;

  @JsonProperty("resourceClaimDetails")
  private List<ResourceClaimDetailsDTO> resourceClaimDetails = null;

  @JsonProperty("statsLastRefreshed")
  private String statsLastRefreshed = null;

  @JsonProperty("totalHeap")
  private String totalHeap = null;

  @JsonProperty("totalHeapBytes")
  private Long totalHeapBytes = null;

  @JsonProperty("totalNonHeap")
  private String totalNonHeap = null;

  @JsonProperty("totalNonHeapBytes")
  private Long totalNonHeapBytes = null;

  @JsonProperty("totalThreads")
  private Integer totalThreads = null;

  @JsonProperty("uptime")
  private String uptime = null;

  @JsonProperty("usedHeap")
  private String usedHeap = null;

  @JsonProperty("usedHeapBytes")
  private Long usedHeapBytes = null;

  @JsonProperty("usedNonHeap")
  private String usedNonHeap = null;

  @JsonProperty("usedNonHeapBytes")
  private Long usedNonHeapBytes = null;

  @JsonProperty("versionInfo")
  private VersionInfoDTO versionInfo = null;

  public SystemDiagnosticsSnapshotDTO availableProcessors(Integer availableProcessors) {
    this.availableProcessors = availableProcessors;
    return this;
  }

   /**
   * Number of available processors if supported by the underlying system.
   * @return availableProcessors
  **/
  @Schema(description = "Number of available processors if supported by the underlying system.")
  public Integer getAvailableProcessors() {
    return availableProcessors;
  }

  public void setAvailableProcessors(Integer availableProcessors) {
    this.availableProcessors = availableProcessors;
  }

  public SystemDiagnosticsSnapshotDTO contentRepositoryStorageUsage(List<StorageUsageDTO> contentRepositoryStorageUsage) {
    this.contentRepositoryStorageUsage = contentRepositoryStorageUsage;
    return this;
  }

  public SystemDiagnosticsSnapshotDTO addContentRepositoryStorageUsageItem(StorageUsageDTO contentRepositoryStorageUsageItem) {
    if (this.contentRepositoryStorageUsage == null) {
      this.contentRepositoryStorageUsage = new ArrayList<>();
    }
    this.contentRepositoryStorageUsage.add(contentRepositoryStorageUsageItem);
    return this;
  }

   /**
   * The content repository storage usage.
   * @return contentRepositoryStorageUsage
  **/
  @Schema(description = "The content repository storage usage.")
  public List<StorageUsageDTO> getContentRepositoryStorageUsage() {
    return contentRepositoryStorageUsage;
  }

  public void setContentRepositoryStorageUsage(List<StorageUsageDTO> contentRepositoryStorageUsage) {
    this.contentRepositoryStorageUsage = contentRepositoryStorageUsage;
  }

  public SystemDiagnosticsSnapshotDTO daemonThreads(Integer daemonThreads) {
    this.daemonThreads = daemonThreads;
    return this;
  }

   /**
   * Number of daemon threads.
   * @return daemonThreads
  **/
  @Schema(description = "Number of daemon threads.")
  public Integer getDaemonThreads() {
    return daemonThreads;
  }

  public void setDaemonThreads(Integer daemonThreads) {
    this.daemonThreads = daemonThreads;
  }

  public SystemDiagnosticsSnapshotDTO flowFileRepositoryStorageUsage(StorageUsageDTO flowFileRepositoryStorageUsage) {
    this.flowFileRepositoryStorageUsage = flowFileRepositoryStorageUsage;
    return this;
  }

   /**
   * Get flowFileRepositoryStorageUsage
   * @return flowFileRepositoryStorageUsage
  **/
  @Schema(description = "")
  public StorageUsageDTO getFlowFileRepositoryStorageUsage() {
    return flowFileRepositoryStorageUsage;
  }

  public void setFlowFileRepositoryStorageUsage(StorageUsageDTO flowFileRepositoryStorageUsage) {
    this.flowFileRepositoryStorageUsage = flowFileRepositoryStorageUsage;
  }

  public SystemDiagnosticsSnapshotDTO freeHeap(String freeHeap) {
    this.freeHeap = freeHeap;
    return this;
  }

   /**
   * Amount of free heap.
   * @return freeHeap
  **/
  @Schema(description = "Amount of free heap.")
  public String getFreeHeap() {
    return freeHeap;
  }

  public void setFreeHeap(String freeHeap) {
    this.freeHeap = freeHeap;
  }

  public SystemDiagnosticsSnapshotDTO freeHeapBytes(Long freeHeapBytes) {
    this.freeHeapBytes = freeHeapBytes;
    return this;
  }

   /**
   * The number of bytes that are allocated to the JVM heap but not currently being used
   * @return freeHeapBytes
  **/
  @Schema(description = "The number of bytes that are allocated to the JVM heap but not currently being used")
  public Long getFreeHeapBytes() {
    return freeHeapBytes;
  }

  public void setFreeHeapBytes(Long freeHeapBytes) {
    this.freeHeapBytes = freeHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO freeNonHeap(String freeNonHeap) {
    this.freeNonHeap = freeNonHeap;
    return this;
  }

   /**
   * Amount of free non heap.
   * @return freeNonHeap
  **/
  @Schema(description = "Amount of free non heap.")
  public String getFreeNonHeap() {
    return freeNonHeap;
  }

  public void setFreeNonHeap(String freeNonHeap) {
    this.freeNonHeap = freeNonHeap;
  }

  public SystemDiagnosticsSnapshotDTO freeNonHeapBytes(Long freeNonHeapBytes) {
    this.freeNonHeapBytes = freeNonHeapBytes;
    return this;
  }

   /**
   * Total number of free non-heap bytes available to the JVM
   * @return freeNonHeapBytes
  **/
  @Schema(description = "Total number of free non-heap bytes available to the JVM")
  public Long getFreeNonHeapBytes() {
    return freeNonHeapBytes;
  }

  public void setFreeNonHeapBytes(Long freeNonHeapBytes) {
    this.freeNonHeapBytes = freeNonHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO garbageCollection(List<GarbageCollectionDTO> garbageCollection) {
    this.garbageCollection = garbageCollection;
    return this;
  }

  public SystemDiagnosticsSnapshotDTO addGarbageCollectionItem(GarbageCollectionDTO garbageCollectionItem) {
    if (this.garbageCollection == null) {
      this.garbageCollection = new ArrayList<>();
    }
    this.garbageCollection.add(garbageCollectionItem);
    return this;
  }

   /**
   * The garbage collection details.
   * @return garbageCollection
  **/
  @Schema(description = "The garbage collection details.")
  public List<GarbageCollectionDTO> getGarbageCollection() {
    return garbageCollection;
  }

  public void setGarbageCollection(List<GarbageCollectionDTO> garbageCollection) {
    this.garbageCollection = garbageCollection;
  }

  public SystemDiagnosticsSnapshotDTO heapUtilization(String heapUtilization) {
    this.heapUtilization = heapUtilization;
    return this;
  }

   /**
   * Utilization of heap.
   * @return heapUtilization
  **/
  @Schema(description = "Utilization of heap.")
  public String getHeapUtilization() {
    return heapUtilization;
  }

  public void setHeapUtilization(String heapUtilization) {
    this.heapUtilization = heapUtilization;
  }

  public SystemDiagnosticsSnapshotDTO maxHeap(String maxHeap) {
    this.maxHeap = maxHeap;
    return this;
  }

   /**
   * Maximum size of heap.
   * @return maxHeap
  **/
  @Schema(description = "Maximum size of heap.")
  public String getMaxHeap() {
    return maxHeap;
  }

  public void setMaxHeap(String maxHeap) {
    this.maxHeap = maxHeap;
  }

  public SystemDiagnosticsSnapshotDTO maxHeapBytes(Long maxHeapBytes) {
    this.maxHeapBytes = maxHeapBytes;
    return this;
  }

   /**
   * The maximum number of bytes that can be used by the JVM
   * @return maxHeapBytes
  **/
  @Schema(description = "The maximum number of bytes that can be used by the JVM")
  public Long getMaxHeapBytes() {
    return maxHeapBytes;
  }

  public void setMaxHeapBytes(Long maxHeapBytes) {
    this.maxHeapBytes = maxHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO maxNonHeap(String maxNonHeap) {
    this.maxNonHeap = maxNonHeap;
    return this;
  }

   /**
   * Maximum size of non heap.
   * @return maxNonHeap
  **/
  @Schema(description = "Maximum size of non heap.")
  public String getMaxNonHeap() {
    return maxNonHeap;
  }

  public void setMaxNonHeap(String maxNonHeap) {
    this.maxNonHeap = maxNonHeap;
  }

  public SystemDiagnosticsSnapshotDTO maxNonHeapBytes(Long maxNonHeapBytes) {
    this.maxNonHeapBytes = maxNonHeapBytes;
    return this;
  }

   /**
   * The maximum number of bytes that the JVM can use for non-heap purposes
   * @return maxNonHeapBytes
  **/
  @Schema(description = "The maximum number of bytes that the JVM can use for non-heap purposes")
  public Long getMaxNonHeapBytes() {
    return maxNonHeapBytes;
  }

  public void setMaxNonHeapBytes(Long maxNonHeapBytes) {
    this.maxNonHeapBytes = maxNonHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO nonHeapUtilization(String nonHeapUtilization) {
    this.nonHeapUtilization = nonHeapUtilization;
    return this;
  }

   /**
   * Utilization of non heap.
   * @return nonHeapUtilization
  **/
  @Schema(description = "Utilization of non heap.")
  public String getNonHeapUtilization() {
    return nonHeapUtilization;
  }

  public void setNonHeapUtilization(String nonHeapUtilization) {
    this.nonHeapUtilization = nonHeapUtilization;
  }

  public SystemDiagnosticsSnapshotDTO processorLoadAverage(Double processorLoadAverage) {
    this.processorLoadAverage = processorLoadAverage;
    return this;
  }

   /**
   * The processor load average if supported by the underlying system.
   * @return processorLoadAverage
  **/
  @Schema(description = "The processor load average if supported by the underlying system.")
  public Double getProcessorLoadAverage() {
    return processorLoadAverage;
  }

  public void setProcessorLoadAverage(Double processorLoadAverage) {
    this.processorLoadAverage = processorLoadAverage;
  }

  public SystemDiagnosticsSnapshotDTO provenanceRepositoryStorageUsage(List<StorageUsageDTO> provenanceRepositoryStorageUsage) {
    this.provenanceRepositoryStorageUsage = provenanceRepositoryStorageUsage;
    return this;
  }

  public SystemDiagnosticsSnapshotDTO addProvenanceRepositoryStorageUsageItem(StorageUsageDTO provenanceRepositoryStorageUsageItem) {
    if (this.provenanceRepositoryStorageUsage == null) {
      this.provenanceRepositoryStorageUsage = new ArrayList<>();
    }
    this.provenanceRepositoryStorageUsage.add(provenanceRepositoryStorageUsageItem);
    return this;
  }

   /**
   * The provenance repository storage usage.
   * @return provenanceRepositoryStorageUsage
  **/
  @Schema(description = "The provenance repository storage usage.")
  public List<StorageUsageDTO> getProvenanceRepositoryStorageUsage() {
    return provenanceRepositoryStorageUsage;
  }

  public void setProvenanceRepositoryStorageUsage(List<StorageUsageDTO> provenanceRepositoryStorageUsage) {
    this.provenanceRepositoryStorageUsage = provenanceRepositoryStorageUsage;
  }

  public SystemDiagnosticsSnapshotDTO resourceClaimDetails(List<ResourceClaimDetailsDTO> resourceClaimDetails) {
    this.resourceClaimDetails = resourceClaimDetails;
    return this;
  }

  public SystemDiagnosticsSnapshotDTO addResourceClaimDetailsItem(ResourceClaimDetailsDTO resourceClaimDetailsItem) {
    if (this.resourceClaimDetails == null) {
      this.resourceClaimDetails = new ArrayList<>();
    }
    this.resourceClaimDetails.add(resourceClaimDetailsItem);
    return this;
  }

   /**
   * Get resourceClaimDetails
   * @return resourceClaimDetails
  **/
  @Schema(description = "")
  public List<ResourceClaimDetailsDTO> getResourceClaimDetails() {
    return resourceClaimDetails;
  }

  public void setResourceClaimDetails(List<ResourceClaimDetailsDTO> resourceClaimDetails) {
    this.resourceClaimDetails = resourceClaimDetails;
  }

  public SystemDiagnosticsSnapshotDTO statsLastRefreshed(String statsLastRefreshed) {
    this.statsLastRefreshed = statsLastRefreshed;
    return this;
  }

   /**
   * When the diagnostics were generated.
   * @return statsLastRefreshed
  **/
  @Schema(description = "When the diagnostics were generated.")
  public String getStatsLastRefreshed() {
    return statsLastRefreshed;
  }

  public void setStatsLastRefreshed(String statsLastRefreshed) {
    this.statsLastRefreshed = statsLastRefreshed;
  }

  public SystemDiagnosticsSnapshotDTO totalHeap(String totalHeap) {
    this.totalHeap = totalHeap;
    return this;
  }

   /**
   * Total size of heap.
   * @return totalHeap
  **/
  @Schema(description = "Total size of heap.")
  public String getTotalHeap() {
    return totalHeap;
  }

  public void setTotalHeap(String totalHeap) {
    this.totalHeap = totalHeap;
  }

  public SystemDiagnosticsSnapshotDTO totalHeapBytes(Long totalHeapBytes) {
    this.totalHeapBytes = totalHeapBytes;
    return this;
  }

   /**
   * The total number of bytes that are available for the JVM heap to use
   * @return totalHeapBytes
  **/
  @Schema(description = "The total number of bytes that are available for the JVM heap to use")
  public Long getTotalHeapBytes() {
    return totalHeapBytes;
  }

  public void setTotalHeapBytes(Long totalHeapBytes) {
    this.totalHeapBytes = totalHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO totalNonHeap(String totalNonHeap) {
    this.totalNonHeap = totalNonHeap;
    return this;
  }

   /**
   * Total size of non heap.
   * @return totalNonHeap
  **/
  @Schema(description = "Total size of non heap.")
  public String getTotalNonHeap() {
    return totalNonHeap;
  }

  public void setTotalNonHeap(String totalNonHeap) {
    this.totalNonHeap = totalNonHeap;
  }

  public SystemDiagnosticsSnapshotDTO totalNonHeapBytes(Long totalNonHeapBytes) {
    this.totalNonHeapBytes = totalNonHeapBytes;
    return this;
  }

   /**
   * Total number of bytes allocated to the JVM not used for heap
   * @return totalNonHeapBytes
  **/
  @Schema(description = "Total number of bytes allocated to the JVM not used for heap")
  public Long getTotalNonHeapBytes() {
    return totalNonHeapBytes;
  }

  public void setTotalNonHeapBytes(Long totalNonHeapBytes) {
    this.totalNonHeapBytes = totalNonHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO totalThreads(Integer totalThreads) {
    this.totalThreads = totalThreads;
    return this;
  }

   /**
   * Total number of threads.
   * @return totalThreads
  **/
  @Schema(description = "Total number of threads.")
  public Integer getTotalThreads() {
    return totalThreads;
  }

  public void setTotalThreads(Integer totalThreads) {
    this.totalThreads = totalThreads;
  }

  public SystemDiagnosticsSnapshotDTO uptime(String uptime) {
    this.uptime = uptime;
    return this;
  }

   /**
   * The uptime of the Java virtual machine
   * @return uptime
  **/
  @Schema(description = "The uptime of the Java virtual machine")
  public String getUptime() {
    return uptime;
  }

  public void setUptime(String uptime) {
    this.uptime = uptime;
  }

  public SystemDiagnosticsSnapshotDTO usedHeap(String usedHeap) {
    this.usedHeap = usedHeap;
    return this;
  }

   /**
   * Amount of used heap.
   * @return usedHeap
  **/
  @Schema(description = "Amount of used heap.")
  public String getUsedHeap() {
    return usedHeap;
  }

  public void setUsedHeap(String usedHeap) {
    this.usedHeap = usedHeap;
  }

  public SystemDiagnosticsSnapshotDTO usedHeapBytes(Long usedHeapBytes) {
    this.usedHeapBytes = usedHeapBytes;
    return this;
  }

   /**
   * The number of bytes of JVM heap that are currently being used
   * @return usedHeapBytes
  **/
  @Schema(description = "The number of bytes of JVM heap that are currently being used")
  public Long getUsedHeapBytes() {
    return usedHeapBytes;
  }

  public void setUsedHeapBytes(Long usedHeapBytes) {
    this.usedHeapBytes = usedHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO usedNonHeap(String usedNonHeap) {
    this.usedNonHeap = usedNonHeap;
    return this;
  }

   /**
   * Amount of use non heap.
   * @return usedNonHeap
  **/
  @Schema(description = "Amount of use non heap.")
  public String getUsedNonHeap() {
    return usedNonHeap;
  }

  public void setUsedNonHeap(String usedNonHeap) {
    this.usedNonHeap = usedNonHeap;
  }

  public SystemDiagnosticsSnapshotDTO usedNonHeapBytes(Long usedNonHeapBytes) {
    this.usedNonHeapBytes = usedNonHeapBytes;
    return this;
  }

   /**
   * Total number of bytes used by the JVM not in the heap space
   * @return usedNonHeapBytes
  **/
  @Schema(description = "Total number of bytes used by the JVM not in the heap space")
  public Long getUsedNonHeapBytes() {
    return usedNonHeapBytes;
  }

  public void setUsedNonHeapBytes(Long usedNonHeapBytes) {
    this.usedNonHeapBytes = usedNonHeapBytes;
  }

  public SystemDiagnosticsSnapshotDTO versionInfo(VersionInfoDTO versionInfo) {
    this.versionInfo = versionInfo;
    return this;
  }

   /**
   * Get versionInfo
   * @return versionInfo
  **/
  @Schema(description = "")
  public VersionInfoDTO getVersionInfo() {
    return versionInfo;
  }

  public void setVersionInfo(VersionInfoDTO versionInfo) {
    this.versionInfo = versionInfo;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SystemDiagnosticsSnapshotDTO systemDiagnosticsSnapshotDTO = (SystemDiagnosticsSnapshotDTO) o;
    return Objects.equals(this.availableProcessors, systemDiagnosticsSnapshotDTO.availableProcessors) &&
        Objects.equals(this.contentRepositoryStorageUsage, systemDiagnosticsSnapshotDTO.contentRepositoryStorageUsage) &&
        Objects.equals(this.daemonThreads, systemDiagnosticsSnapshotDTO.daemonThreads) &&
        Objects.equals(this.flowFileRepositoryStorageUsage, systemDiagnosticsSnapshotDTO.flowFileRepositoryStorageUsage) &&
        Objects.equals(this.freeHeap, systemDiagnosticsSnapshotDTO.freeHeap) &&
        Objects.equals(this.freeHeapBytes, systemDiagnosticsSnapshotDTO.freeHeapBytes) &&
        Objects.equals(this.freeNonHeap, systemDiagnosticsSnapshotDTO.freeNonHeap) &&
        Objects.equals(this.freeNonHeapBytes, systemDiagnosticsSnapshotDTO.freeNonHeapBytes) &&
        Objects.equals(this.garbageCollection, systemDiagnosticsSnapshotDTO.garbageCollection) &&
        Objects.equals(this.heapUtilization, systemDiagnosticsSnapshotDTO.heapUtilization) &&
        Objects.equals(this.maxHeap, systemDiagnosticsSnapshotDTO.maxHeap) &&
        Objects.equals(this.maxHeapBytes, systemDiagnosticsSnapshotDTO.maxHeapBytes) &&
        Objects.equals(this.maxNonHeap, systemDiagnosticsSnapshotDTO.maxNonHeap) &&
        Objects.equals(this.maxNonHeapBytes, systemDiagnosticsSnapshotDTO.maxNonHeapBytes) &&
        Objects.equals(this.nonHeapUtilization, systemDiagnosticsSnapshotDTO.nonHeapUtilization) &&
        Objects.equals(this.processorLoadAverage, systemDiagnosticsSnapshotDTO.processorLoadAverage) &&
        Objects.equals(this.provenanceRepositoryStorageUsage, systemDiagnosticsSnapshotDTO.provenanceRepositoryStorageUsage) &&
        Objects.equals(this.resourceClaimDetails, systemDiagnosticsSnapshotDTO.resourceClaimDetails) &&
        Objects.equals(this.statsLastRefreshed, systemDiagnosticsSnapshotDTO.statsLastRefreshed) &&
        Objects.equals(this.totalHeap, systemDiagnosticsSnapshotDTO.totalHeap) &&
        Objects.equals(this.totalHeapBytes, systemDiagnosticsSnapshotDTO.totalHeapBytes) &&
        Objects.equals(this.totalNonHeap, systemDiagnosticsSnapshotDTO.totalNonHeap) &&
        Objects.equals(this.totalNonHeapBytes, systemDiagnosticsSnapshotDTO.totalNonHeapBytes) &&
        Objects.equals(this.totalThreads, systemDiagnosticsSnapshotDTO.totalThreads) &&
        Objects.equals(this.uptime, systemDiagnosticsSnapshotDTO.uptime) &&
        Objects.equals(this.usedHeap, systemDiagnosticsSnapshotDTO.usedHeap) &&
        Objects.equals(this.usedHeapBytes, systemDiagnosticsSnapshotDTO.usedHeapBytes) &&
        Objects.equals(this.usedNonHeap, systemDiagnosticsSnapshotDTO.usedNonHeap) &&
        Objects.equals(this.usedNonHeapBytes, systemDiagnosticsSnapshotDTO.usedNonHeapBytes) &&
        Objects.equals(this.versionInfo, systemDiagnosticsSnapshotDTO.versionInfo);
  }

  @Override
  public int hashCode() {
    return Objects.hash(availableProcessors, contentRepositoryStorageUsage, daemonThreads, flowFileRepositoryStorageUsage, freeHeap, freeHeapBytes, freeNonHeap, freeNonHeapBytes, garbageCollection, heapUtilization, maxHeap, maxHeapBytes, maxNonHeap, maxNonHeapBytes, nonHeapUtilization, processorLoadAverage, provenanceRepositoryStorageUsage, resourceClaimDetails, statsLastRefreshed, totalHeap, totalHeapBytes, totalNonHeap, totalNonHeapBytes, totalThreads, uptime, usedHeap, usedHeapBytes, usedNonHeap, usedNonHeapBytes, versionInfo);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SystemDiagnosticsSnapshotDTO {\n");
    
    sb.append("    availableProcessors: ").append(toIndentedString(availableProcessors)).append("\n");
    sb.append("    contentRepositoryStorageUsage: ").append(toIndentedString(contentRepositoryStorageUsage)).append("\n");
    sb.append("    daemonThreads: ").append(toIndentedString(daemonThreads)).append("\n");
    sb.append("    flowFileRepositoryStorageUsage: ").append(toIndentedString(flowFileRepositoryStorageUsage)).append("\n");
    sb.append("    freeHeap: ").append(toIndentedString(freeHeap)).append("\n");
    sb.append("    freeHeapBytes: ").append(toIndentedString(freeHeapBytes)).append("\n");
    sb.append("    freeNonHeap: ").append(toIndentedString(freeNonHeap)).append("\n");
    sb.append("    freeNonHeapBytes: ").append(toIndentedString(freeNonHeapBytes)).append("\n");
    sb.append("    garbageCollection: ").append(toIndentedString(garbageCollection)).append("\n");
    sb.append("    heapUtilization: ").append(toIndentedString(heapUtilization)).append("\n");
    sb.append("    maxHeap: ").append(toIndentedString(maxHeap)).append("\n");
    sb.append("    maxHeapBytes: ").append(toIndentedString(maxHeapBytes)).append("\n");
    sb.append("    maxNonHeap: ").append(toIndentedString(maxNonHeap)).append("\n");
    sb.append("    maxNonHeapBytes: ").append(toIndentedString(maxNonHeapBytes)).append("\n");
    sb.append("    nonHeapUtilization: ").append(toIndentedString(nonHeapUtilization)).append("\n");
    sb.append("    processorLoadAverage: ").append(toIndentedString(processorLoadAverage)).append("\n");
    sb.append("    provenanceRepositoryStorageUsage: ").append(toIndentedString(provenanceRepositoryStorageUsage)).append("\n");
    sb.append("    resourceClaimDetails: ").append(toIndentedString(resourceClaimDetails)).append("\n");
    sb.append("    statsLastRefreshed: ").append(toIndentedString(statsLastRefreshed)).append("\n");
    sb.append("    totalHeap: ").append(toIndentedString(totalHeap)).append("\n");
    sb.append("    totalHeapBytes: ").append(toIndentedString(totalHeapBytes)).append("\n");
    sb.append("    totalNonHeap: ").append(toIndentedString(totalNonHeap)).append("\n");
    sb.append("    totalNonHeapBytes: ").append(toIndentedString(totalNonHeapBytes)).append("\n");
    sb.append("    totalThreads: ").append(toIndentedString(totalThreads)).append("\n");
    sb.append("    uptime: ").append(toIndentedString(uptime)).append("\n");
    sb.append("    usedHeap: ").append(toIndentedString(usedHeap)).append("\n");
    sb.append("    usedHeapBytes: ").append(toIndentedString(usedHeapBytes)).append("\n");
    sb.append("    usedNonHeap: ").append(toIndentedString(usedNonHeap)).append("\n");
    sb.append("    usedNonHeapBytes: ").append(toIndentedString(usedNonHeapBytes)).append("\n");
    sb.append("    versionInfo: ").append(toIndentedString(versionInfo)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
