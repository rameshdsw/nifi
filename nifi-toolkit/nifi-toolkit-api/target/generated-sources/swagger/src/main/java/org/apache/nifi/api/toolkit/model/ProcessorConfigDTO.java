/*
 * Apache NiFi REST API
 * REST API definition for Apache NiFi web services
 *
 * OpenAPI spec version: 2.4.0
 * Contact: dev@nifi.apache.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.apache.nifi.api.toolkit.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.nifi.api.toolkit.model.PropertyDescriptorDTO;
/**
 * The configuration details for the processor. These details will be included in a response if the verbose flag is included in a request.
 */
@Schema(description = "The configuration details for the processor. These details will be included in a response if the verbose flag is included in a request.")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2025-09-03T13:15:23.252321740+05:30[Asia/Kolkata]")

public class ProcessorConfigDTO {
  @JsonProperty("annotationData")
  private String annotationData = null;

  @JsonProperty("autoTerminatedRelationships")
  private List<String> autoTerminatedRelationships = null;

  /**
   * Determines whether the FlowFile should be penalized or the processor should be yielded between retries.
   */
  public enum BackoffMechanismEnum {
    PENALIZE_FLOWFILE("PENALIZE_FLOWFILE"),
    YIELD_PROCESSOR("YIELD_PROCESSOR");

    private String value;

    BackoffMechanismEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static BackoffMechanismEnum fromValue(String input) {
      for (BackoffMechanismEnum b : BackoffMechanismEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("backoffMechanism")
  private BackoffMechanismEnum backoffMechanism = null;

  @JsonProperty("bulletinLevel")
  private String bulletinLevel = null;

  @JsonProperty("comments")
  private String comments = null;

  @JsonProperty("concurrentlySchedulableTaskCount")
  private Integer concurrentlySchedulableTaskCount = null;

  @JsonProperty("customUiUrl")
  private String customUiUrl = null;

  @JsonProperty("defaultConcurrentTasks")
  private Map<String, String> defaultConcurrentTasks = null;

  @JsonProperty("defaultSchedulingPeriod")
  private Map<String, String> defaultSchedulingPeriod = null;

  @JsonProperty("descriptors")
  private Map<String, PropertyDescriptorDTO> descriptors = null;

  @JsonProperty("executionNode")
  private String executionNode = null;

  @JsonProperty("lossTolerant")
  private Boolean lossTolerant = null;

  @JsonProperty("maxBackoffPeriod")
  private String maxBackoffPeriod = null;

  @JsonProperty("penaltyDuration")
  private String penaltyDuration = null;

  @JsonProperty("properties")
  private Map<String, String> properties = null;

  @JsonProperty("retriedRelationships")
  private List<String> retriedRelationships = null;

  @JsonProperty("retryCount")
  private Integer retryCount = null;

  @JsonProperty("runDurationMillis")
  private Long runDurationMillis = null;

  @JsonProperty("schedulingPeriod")
  private String schedulingPeriod = null;

  @JsonProperty("schedulingStrategy")
  private String schedulingStrategy = null;

  @JsonProperty("sensitiveDynamicPropertyNames")
  private List<String> sensitiveDynamicPropertyNames = null;

  @JsonProperty("yieldDuration")
  private String yieldDuration = null;

  public ProcessorConfigDTO annotationData(String annotationData) {
    this.annotationData = annotationData;
    return this;
  }

   /**
   * The annotation data for the processor used to relay configuration between a custom UI and the procesosr.
   * @return annotationData
  **/
  @Schema(description = "The annotation data for the processor used to relay configuration between a custom UI and the procesosr.")
  public String getAnnotationData() {
    return annotationData;
  }

  public void setAnnotationData(String annotationData) {
    this.annotationData = annotationData;
  }

  public ProcessorConfigDTO autoTerminatedRelationships(List<String> autoTerminatedRelationships) {
    this.autoTerminatedRelationships = autoTerminatedRelationships;
    return this;
  }

  public ProcessorConfigDTO addAutoTerminatedRelationshipsItem(String autoTerminatedRelationshipsItem) {
    if (this.autoTerminatedRelationships == null) {
      this.autoTerminatedRelationships = new ArrayList<>();
    }
    this.autoTerminatedRelationships.add(autoTerminatedRelationshipsItem);
    return this;
  }

   /**
   * The names of all relationships that cause a flow file to be terminated if the relationship is not connected elsewhere. This property differs from the &#x27;isAutoTerminate&#x27; property of the RelationshipDTO in that the RelationshipDTO is meant to depict the current configuration, whereas this property can be set in a DTO when updating a Processor in order to change which Relationships should be auto-terminated.
   * @return autoTerminatedRelationships
  **/
  @Schema(description = "The names of all relationships that cause a flow file to be terminated if the relationship is not connected elsewhere. This property differs from the 'isAutoTerminate' property of the RelationshipDTO in that the RelationshipDTO is meant to depict the current configuration, whereas this property can be set in a DTO when updating a Processor in order to change which Relationships should be auto-terminated.")
  public List<String> getAutoTerminatedRelationships() {
    return autoTerminatedRelationships;
  }

  public void setAutoTerminatedRelationships(List<String> autoTerminatedRelationships) {
    this.autoTerminatedRelationships = autoTerminatedRelationships;
  }

  public ProcessorConfigDTO backoffMechanism(BackoffMechanismEnum backoffMechanism) {
    this.backoffMechanism = backoffMechanism;
    return this;
  }

   /**
   * Determines whether the FlowFile should be penalized or the processor should be yielded between retries.
   * @return backoffMechanism
  **/
  @Schema(description = "Determines whether the FlowFile should be penalized or the processor should be yielded between retries.")
  public BackoffMechanismEnum getBackoffMechanism() {
    return backoffMechanism;
  }

  public void setBackoffMechanism(BackoffMechanismEnum backoffMechanism) {
    this.backoffMechanism = backoffMechanism;
  }

  public ProcessorConfigDTO bulletinLevel(String bulletinLevel) {
    this.bulletinLevel = bulletinLevel;
    return this;
  }

   /**
   * The level at which the processor will report bulletins.
   * @return bulletinLevel
  **/
  @Schema(description = "The level at which the processor will report bulletins.")
  public String getBulletinLevel() {
    return bulletinLevel;
  }

  public void setBulletinLevel(String bulletinLevel) {
    this.bulletinLevel = bulletinLevel;
  }

  public ProcessorConfigDTO comments(String comments) {
    this.comments = comments;
    return this;
  }

   /**
   * The comments for the processor.
   * @return comments
  **/
  @Schema(description = "The comments for the processor.")
  public String getComments() {
    return comments;
  }

  public void setComments(String comments) {
    this.comments = comments;
  }

  public ProcessorConfigDTO concurrentlySchedulableTaskCount(Integer concurrentlySchedulableTaskCount) {
    this.concurrentlySchedulableTaskCount = concurrentlySchedulableTaskCount;
    return this;
  }

   /**
   * The number of tasks that should be concurrently schedule for the processor. If the processor doesn&#x27;t allow parallol processing then any positive input will be ignored.
   * @return concurrentlySchedulableTaskCount
  **/
  @Schema(description = "The number of tasks that should be concurrently schedule for the processor. If the processor doesn't allow parallol processing then any positive input will be ignored.")
  public Integer getConcurrentlySchedulableTaskCount() {
    return concurrentlySchedulableTaskCount;
  }

  public void setConcurrentlySchedulableTaskCount(Integer concurrentlySchedulableTaskCount) {
    this.concurrentlySchedulableTaskCount = concurrentlySchedulableTaskCount;
  }

  public ProcessorConfigDTO customUiUrl(String customUiUrl) {
    this.customUiUrl = customUiUrl;
    return this;
  }

   /**
   * The URL for the processor&#x27;s custom configuration UI if applicable.
   * @return customUiUrl
  **/
  @Schema(description = "The URL for the processor's custom configuration UI if applicable.")
  public String getCustomUiUrl() {
    return customUiUrl;
  }

  public void setCustomUiUrl(String customUiUrl) {
    this.customUiUrl = customUiUrl;
  }

  public ProcessorConfigDTO defaultConcurrentTasks(Map<String, String> defaultConcurrentTasks) {
    this.defaultConcurrentTasks = defaultConcurrentTasks;
    return this;
  }

  public ProcessorConfigDTO putDefaultConcurrentTasksItem(String key, String defaultConcurrentTasksItem) {
    if (this.defaultConcurrentTasks == null) {
      this.defaultConcurrentTasks = new HashMap<>();
    }
    this.defaultConcurrentTasks.put(key, defaultConcurrentTasksItem);
    return this;
  }

   /**
   * Maps default values for concurrent tasks for each applicable scheduling strategy.
   * @return defaultConcurrentTasks
  **/
  @Schema(description = "Maps default values for concurrent tasks for each applicable scheduling strategy.")
  public Map<String, String> getDefaultConcurrentTasks() {
    return defaultConcurrentTasks;
  }

  public void setDefaultConcurrentTasks(Map<String, String> defaultConcurrentTasks) {
    this.defaultConcurrentTasks = defaultConcurrentTasks;
  }

  public ProcessorConfigDTO defaultSchedulingPeriod(Map<String, String> defaultSchedulingPeriod) {
    this.defaultSchedulingPeriod = defaultSchedulingPeriod;
    return this;
  }

  public ProcessorConfigDTO putDefaultSchedulingPeriodItem(String key, String defaultSchedulingPeriodItem) {
    if (this.defaultSchedulingPeriod == null) {
      this.defaultSchedulingPeriod = new HashMap<>();
    }
    this.defaultSchedulingPeriod.put(key, defaultSchedulingPeriodItem);
    return this;
  }

   /**
   * Maps default values for scheduling period for each applicable scheduling strategy.
   * @return defaultSchedulingPeriod
  **/
  @Schema(description = "Maps default values for scheduling period for each applicable scheduling strategy.")
  public Map<String, String> getDefaultSchedulingPeriod() {
    return defaultSchedulingPeriod;
  }

  public void setDefaultSchedulingPeriod(Map<String, String> defaultSchedulingPeriod) {
    this.defaultSchedulingPeriod = defaultSchedulingPeriod;
  }

  public ProcessorConfigDTO descriptors(Map<String, PropertyDescriptorDTO> descriptors) {
    this.descriptors = descriptors;
    return this;
  }

  public ProcessorConfigDTO putDescriptorsItem(String key, PropertyDescriptorDTO descriptorsItem) {
    if (this.descriptors == null) {
      this.descriptors = new HashMap<>();
    }
    this.descriptors.put(key, descriptorsItem);
    return this;
  }

   /**
   * Descriptors for the processor&#x27;s properties.
   * @return descriptors
  **/
  @Schema(description = "Descriptors for the processor's properties.")
  public Map<String, PropertyDescriptorDTO> getDescriptors() {
    return descriptors;
  }

  public void setDescriptors(Map<String, PropertyDescriptorDTO> descriptors) {
    this.descriptors = descriptors;
  }

  public ProcessorConfigDTO executionNode(String executionNode) {
    this.executionNode = executionNode;
    return this;
  }

   /**
   * Indicates the node where the process will execute.
   * @return executionNode
  **/
  @Schema(description = "Indicates the node where the process will execute.")
  public String getExecutionNode() {
    return executionNode;
  }

  public void setExecutionNode(String executionNode) {
    this.executionNode = executionNode;
  }

  public ProcessorConfigDTO lossTolerant(Boolean lossTolerant) {
    this.lossTolerant = lossTolerant;
    return this;
  }

   /**
   * Whether the processor is loss tolerant.
   * @return lossTolerant
  **/
  @Schema(description = "Whether the processor is loss tolerant.")
  public Boolean isLossTolerant() {
    return lossTolerant;
  }

  public void setLossTolerant(Boolean lossTolerant) {
    this.lossTolerant = lossTolerant;
  }

  public ProcessorConfigDTO maxBackoffPeriod(String maxBackoffPeriod) {
    this.maxBackoffPeriod = maxBackoffPeriod;
    return this;
  }

   /**
   * Maximum amount of time to be waited during a retry period.
   * @return maxBackoffPeriod
  **/
  @Schema(description = "Maximum amount of time to be waited during a retry period.")
  public String getMaxBackoffPeriod() {
    return maxBackoffPeriod;
  }

  public void setMaxBackoffPeriod(String maxBackoffPeriod) {
    this.maxBackoffPeriod = maxBackoffPeriod;
  }

  public ProcessorConfigDTO penaltyDuration(String penaltyDuration) {
    this.penaltyDuration = penaltyDuration;
    return this;
  }

   /**
   * The amount of time that is used when the process penalizes a flowfile.
   * @return penaltyDuration
  **/
  @Schema(description = "The amount of time that is used when the process penalizes a flowfile.")
  public String getPenaltyDuration() {
    return penaltyDuration;
  }

  public void setPenaltyDuration(String penaltyDuration) {
    this.penaltyDuration = penaltyDuration;
  }

  public ProcessorConfigDTO properties(Map<String, String> properties) {
    this.properties = properties;
    return this;
  }

  public ProcessorConfigDTO putPropertiesItem(String key, String propertiesItem) {
    if (this.properties == null) {
      this.properties = new HashMap<>();
    }
    this.properties.put(key, propertiesItem);
    return this;
  }

   /**
   * The properties for the processor. Properties whose value is not set will only contain the property name.
   * @return properties
  **/
  @Schema(description = "The properties for the processor. Properties whose value is not set will only contain the property name.")
  public Map<String, String> getProperties() {
    return properties;
  }

  public void setProperties(Map<String, String> properties) {
    this.properties = properties;
  }

  public ProcessorConfigDTO retriedRelationships(List<String> retriedRelationships) {
    this.retriedRelationships = retriedRelationships;
    return this;
  }

  public ProcessorConfigDTO addRetriedRelationshipsItem(String retriedRelationshipsItem) {
    if (this.retriedRelationships == null) {
      this.retriedRelationships = new ArrayList<>();
    }
    this.retriedRelationships.add(retriedRelationshipsItem);
    return this;
  }

   /**
   * All the relationships should be retried.
   * @return retriedRelationships
  **/
  @Schema(description = "All the relationships should be retried.")
  public List<String> getRetriedRelationships() {
    return retriedRelationships;
  }

  public void setRetriedRelationships(List<String> retriedRelationships) {
    this.retriedRelationships = retriedRelationships;
  }

  public ProcessorConfigDTO retryCount(Integer retryCount) {
    this.retryCount = retryCount;
    return this;
  }

   /**
   * Overall number of retries.
   * @return retryCount
  **/
  @Schema(description = "Overall number of retries.")
  public Integer getRetryCount() {
    return retryCount;
  }

  public void setRetryCount(Integer retryCount) {
    this.retryCount = retryCount;
  }

  public ProcessorConfigDTO runDurationMillis(Long runDurationMillis) {
    this.runDurationMillis = runDurationMillis;
    return this;
  }

   /**
   * The run duration for the processor in milliseconds.
   * @return runDurationMillis
  **/
  @Schema(description = "The run duration for the processor in milliseconds.")
  public Long getRunDurationMillis() {
    return runDurationMillis;
  }

  public void setRunDurationMillis(Long runDurationMillis) {
    this.runDurationMillis = runDurationMillis;
  }

  public ProcessorConfigDTO schedulingPeriod(String schedulingPeriod) {
    this.schedulingPeriod = schedulingPeriod;
    return this;
  }

   /**
   * The frequency with which to schedule the processor. The format of the value will depend on th value of schedulingStrategy.
   * @return schedulingPeriod
  **/
  @Schema(description = "The frequency with which to schedule the processor. The format of the value will depend on th value of schedulingStrategy.")
  public String getSchedulingPeriod() {
    return schedulingPeriod;
  }

  public void setSchedulingPeriod(String schedulingPeriod) {
    this.schedulingPeriod = schedulingPeriod;
  }

  public ProcessorConfigDTO schedulingStrategy(String schedulingStrategy) {
    this.schedulingStrategy = schedulingStrategy;
    return this;
  }

   /**
   * Indicates how the processor should be scheduled to run.
   * @return schedulingStrategy
  **/
  @Schema(description = "Indicates how the processor should be scheduled to run.")
  public String getSchedulingStrategy() {
    return schedulingStrategy;
  }

  public void setSchedulingStrategy(String schedulingStrategy) {
    this.schedulingStrategy = schedulingStrategy;
  }

  public ProcessorConfigDTO sensitiveDynamicPropertyNames(List<String> sensitiveDynamicPropertyNames) {
    this.sensitiveDynamicPropertyNames = sensitiveDynamicPropertyNames;
    return this;
  }

  public ProcessorConfigDTO addSensitiveDynamicPropertyNamesItem(String sensitiveDynamicPropertyNamesItem) {
    if (this.sensitiveDynamicPropertyNames == null) {
      this.sensitiveDynamicPropertyNames = new ArrayList<>();
    }
    this.sensitiveDynamicPropertyNames.add(sensitiveDynamicPropertyNamesItem);
    return this;
  }

   /**
   * Set of sensitive dynamic property names
   * @return sensitiveDynamicPropertyNames
  **/
  @Schema(description = "Set of sensitive dynamic property names")
  public List<String> getSensitiveDynamicPropertyNames() {
    return sensitiveDynamicPropertyNames;
  }

  public void setSensitiveDynamicPropertyNames(List<String> sensitiveDynamicPropertyNames) {
    this.sensitiveDynamicPropertyNames = sensitiveDynamicPropertyNames;
  }

  public ProcessorConfigDTO yieldDuration(String yieldDuration) {
    this.yieldDuration = yieldDuration;
    return this;
  }

   /**
   * The amount of time that must elapse before this processor is scheduled again after yielding.
   * @return yieldDuration
  **/
  @Schema(description = "The amount of time that must elapse before this processor is scheduled again after yielding.")
  public String getYieldDuration() {
    return yieldDuration;
  }

  public void setYieldDuration(String yieldDuration) {
    this.yieldDuration = yieldDuration;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ProcessorConfigDTO processorConfigDTO = (ProcessorConfigDTO) o;
    return Objects.equals(this.annotationData, processorConfigDTO.annotationData) &&
        Objects.equals(this.autoTerminatedRelationships, processorConfigDTO.autoTerminatedRelationships) &&
        Objects.equals(this.backoffMechanism, processorConfigDTO.backoffMechanism) &&
        Objects.equals(this.bulletinLevel, processorConfigDTO.bulletinLevel) &&
        Objects.equals(this.comments, processorConfigDTO.comments) &&
        Objects.equals(this.concurrentlySchedulableTaskCount, processorConfigDTO.concurrentlySchedulableTaskCount) &&
        Objects.equals(this.customUiUrl, processorConfigDTO.customUiUrl) &&
        Objects.equals(this.defaultConcurrentTasks, processorConfigDTO.defaultConcurrentTasks) &&
        Objects.equals(this.defaultSchedulingPeriod, processorConfigDTO.defaultSchedulingPeriod) &&
        Objects.equals(this.descriptors, processorConfigDTO.descriptors) &&
        Objects.equals(this.executionNode, processorConfigDTO.executionNode) &&
        Objects.equals(this.lossTolerant, processorConfigDTO.lossTolerant) &&
        Objects.equals(this.maxBackoffPeriod, processorConfigDTO.maxBackoffPeriod) &&
        Objects.equals(this.penaltyDuration, processorConfigDTO.penaltyDuration) &&
        Objects.equals(this.properties, processorConfigDTO.properties) &&
        Objects.equals(this.retriedRelationships, processorConfigDTO.retriedRelationships) &&
        Objects.equals(this.retryCount, processorConfigDTO.retryCount) &&
        Objects.equals(this.runDurationMillis, processorConfigDTO.runDurationMillis) &&
        Objects.equals(this.schedulingPeriod, processorConfigDTO.schedulingPeriod) &&
        Objects.equals(this.schedulingStrategy, processorConfigDTO.schedulingStrategy) &&
        Objects.equals(this.sensitiveDynamicPropertyNames, processorConfigDTO.sensitiveDynamicPropertyNames) &&
        Objects.equals(this.yieldDuration, processorConfigDTO.yieldDuration);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotationData, autoTerminatedRelationships, backoffMechanism, bulletinLevel, comments, concurrentlySchedulableTaskCount, customUiUrl, defaultConcurrentTasks, defaultSchedulingPeriod, descriptors, executionNode, lossTolerant, maxBackoffPeriod, penaltyDuration, properties, retriedRelationships, retryCount, runDurationMillis, schedulingPeriod, schedulingStrategy, sensitiveDynamicPropertyNames, yieldDuration);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ProcessorConfigDTO {\n");
    
    sb.append("    annotationData: ").append(toIndentedString(annotationData)).append("\n");
    sb.append("    autoTerminatedRelationships: ").append(toIndentedString(autoTerminatedRelationships)).append("\n");
    sb.append("    backoffMechanism: ").append(toIndentedString(backoffMechanism)).append("\n");
    sb.append("    bulletinLevel: ").append(toIndentedString(bulletinLevel)).append("\n");
    sb.append("    comments: ").append(toIndentedString(comments)).append("\n");
    sb.append("    concurrentlySchedulableTaskCount: ").append(toIndentedString(concurrentlySchedulableTaskCount)).append("\n");
    sb.append("    customUiUrl: ").append(toIndentedString(customUiUrl)).append("\n");
    sb.append("    defaultConcurrentTasks: ").append(toIndentedString(defaultConcurrentTasks)).append("\n");
    sb.append("    defaultSchedulingPeriod: ").append(toIndentedString(defaultSchedulingPeriod)).append("\n");
    sb.append("    descriptors: ").append(toIndentedString(descriptors)).append("\n");
    sb.append("    executionNode: ").append(toIndentedString(executionNode)).append("\n");
    sb.append("    lossTolerant: ").append(toIndentedString(lossTolerant)).append("\n");
    sb.append("    maxBackoffPeriod: ").append(toIndentedString(maxBackoffPeriod)).append("\n");
    sb.append("    penaltyDuration: ").append(toIndentedString(penaltyDuration)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    retriedRelationships: ").append(toIndentedString(retriedRelationships)).append("\n");
    sb.append("    retryCount: ").append(toIndentedString(retryCount)).append("\n");
    sb.append("    runDurationMillis: ").append(toIndentedString(runDurationMillis)).append("\n");
    sb.append("    schedulingPeriod: ").append(toIndentedString(schedulingPeriod)).append("\n");
    sb.append("    schedulingStrategy: ").append(toIndentedString(schedulingStrategy)).append("\n");
    sb.append("    sensitiveDynamicPropertyNames: ").append(toIndentedString(sensitiveDynamicPropertyNames)).append("\n");
    sb.append("    yieldDuration: ").append(toIndentedString(yieldDuration)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
