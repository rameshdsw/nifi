/*
 * Apache NiFi REST API
 * REST API definition for Apache NiFi web services
 *
 * OpenAPI spec version: 2.4.0
 * Contact: dev@nifi.apache.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.apache.nifi.api.toolkit.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.List;
import org.apache.nifi.api.toolkit.model.ConnectableComponent;
import org.apache.nifi.api.toolkit.model.Position;
/**
 * The Connections
 */
@Schema(description = "The Connections")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2025-09-03T13:15:23.252321740+05:30[Asia/Kolkata]")

public class VersionedConnection {
  @JsonProperty("backPressureDataSizeThreshold")
  private String backPressureDataSizeThreshold = null;

  @JsonProperty("backPressureObjectThreshold")
  private Long backPressureObjectThreshold = null;

  @JsonProperty("bends")
  private List<Position> bends = null;

  @JsonProperty("comments")
  private String comments = null;

  /**
   * Gets or Sets componentType
   */
  public enum ComponentTypeEnum {
    CONNECTION("CONNECTION"),
    PROCESSOR("PROCESSOR"),
    PROCESS_GROUP("PROCESS_GROUP"),
    REMOTE_PROCESS_GROUP("REMOTE_PROCESS_GROUP"),
    INPUT_PORT("INPUT_PORT"),
    OUTPUT_PORT("OUTPUT_PORT"),
    REMOTE_INPUT_PORT("REMOTE_INPUT_PORT"),
    REMOTE_OUTPUT_PORT("REMOTE_OUTPUT_PORT"),
    FUNNEL("FUNNEL"),
    LABEL("LABEL"),
    CONTROLLER_SERVICE("CONTROLLER_SERVICE"),
    REPORTING_TASK("REPORTING_TASK"),
    FLOW_ANALYSIS_RULE("FLOW_ANALYSIS_RULE"),
    PARAMETER_CONTEXT("PARAMETER_CONTEXT"),
    PARAMETER_PROVIDER("PARAMETER_PROVIDER"),
    FLOW_REGISTRY_CLIENT("FLOW_REGISTRY_CLIENT");

    private String value;

    ComponentTypeEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static ComponentTypeEnum fromValue(String input) {
      for (ComponentTypeEnum b : ComponentTypeEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("componentType")
  private ComponentTypeEnum componentType = null;

  @JsonProperty("destination")
  private ConnectableComponent destination = null;

  @JsonProperty("flowFileExpiration")
  private String flowFileExpiration = null;

  @JsonProperty("groupIdentifier")
  private String groupIdentifier = null;

  @JsonProperty("identifier")
  private String identifier = null;

  @JsonProperty("instanceIdentifier")
  private String instanceIdentifier = null;

  @JsonProperty("labelIndex")
  private Integer labelIndex = null;

  /**
   * Whether or not compression should be used when transferring FlowFiles between nodes
   */
  public enum LoadBalanceCompressionEnum {
    DO_NOT_COMPRESS_COMPRESS_ATTRIBUTES_ONLY_COMPRESS_ATTRIBUTES_AND_CONTENT("DO_NOT_COMPRESS, COMPRESS_ATTRIBUTES_ONLY, COMPRESS_ATTRIBUTES_AND_CONTENT");

    private String value;

    LoadBalanceCompressionEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static LoadBalanceCompressionEnum fromValue(String input) {
      for (LoadBalanceCompressionEnum b : LoadBalanceCompressionEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("loadBalanceCompression")
  private LoadBalanceCompressionEnum loadBalanceCompression = null;

  /**
   * The Strategy to use for load balancing data across the cluster, or null, if no Load Balance Strategy has been specified.
   */
  public enum LoadBalanceStrategyEnum {
    DO_NOT_LOAD_BALANCE_PARTITION_BY_ATTRIBUTE_ROUND_ROBIN_SINGLE_NODE("DO_NOT_LOAD_BALANCE, PARTITION_BY_ATTRIBUTE, ROUND_ROBIN, SINGLE_NODE");

    private String value;

    LoadBalanceStrategyEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static LoadBalanceStrategyEnum fromValue(String input) {
      for (LoadBalanceStrategyEnum b : LoadBalanceStrategyEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("loadBalanceStrategy")
  private LoadBalanceStrategyEnum loadBalanceStrategy = null;

  @JsonProperty("name")
  private String name = null;

  @JsonProperty("partitioningAttribute")
  private String partitioningAttribute = null;

  @JsonProperty("position")
  private Position position = null;

  @JsonProperty("prioritizers")
  private List<String> prioritizers = null;

  @JsonProperty("selectedRelationships")
  private List<String> selectedRelationships = null;

  @JsonProperty("source")
  private ConnectableComponent source = null;

  @JsonProperty("zIndex")
  private Long zIndex = null;

  public VersionedConnection backPressureDataSizeThreshold(String backPressureDataSizeThreshold) {
    this.backPressureDataSizeThreshold = backPressureDataSizeThreshold;
    return this;
  }

   /**
   * The object data size threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won&#x27;t impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.
   * @return backPressureDataSizeThreshold
  **/
  @Schema(description = "The object data size threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won't impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.")
  public String getBackPressureDataSizeThreshold() {
    return backPressureDataSizeThreshold;
  }

  public void setBackPressureDataSizeThreshold(String backPressureDataSizeThreshold) {
    this.backPressureDataSizeThreshold = backPressureDataSizeThreshold;
  }

  public VersionedConnection backPressureObjectThreshold(Long backPressureObjectThreshold) {
    this.backPressureObjectThreshold = backPressureObjectThreshold;
    return this;
  }

   /**
   * The object count threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won&#x27;t impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.
   * @return backPressureObjectThreshold
  **/
  @Schema(description = "The object count threshold for determining when back pressure is applied. Updating this value is a passive change in the sense that it won't impact whether existing files over the limit are affected but it does help feeder processors to stop pushing too much into this work queue.")
  public Long getBackPressureObjectThreshold() {
    return backPressureObjectThreshold;
  }

  public void setBackPressureObjectThreshold(Long backPressureObjectThreshold) {
    this.backPressureObjectThreshold = backPressureObjectThreshold;
  }

  public VersionedConnection bends(List<Position> bends) {
    this.bends = bends;
    return this;
  }

  public VersionedConnection addBendsItem(Position bendsItem) {
    if (this.bends == null) {
      this.bends = new ArrayList<>();
    }
    this.bends.add(bendsItem);
    return this;
  }

   /**
   * The bend points on the connection.
   * @return bends
  **/
  @Schema(description = "The bend points on the connection.")
  public List<Position> getBends() {
    return bends;
  }

  public void setBends(List<Position> bends) {
    this.bends = bends;
  }

  public VersionedConnection comments(String comments) {
    this.comments = comments;
    return this;
  }

   /**
   * The user-supplied comments for the component
   * @return comments
  **/
  @Schema(description = "The user-supplied comments for the component")
  public String getComments() {
    return comments;
  }

  public void setComments(String comments) {
    this.comments = comments;
  }

  public VersionedConnection componentType(ComponentTypeEnum componentType) {
    this.componentType = componentType;
    return this;
  }

   /**
   * Get componentType
   * @return componentType
  **/
  @Schema(description = "")
  public ComponentTypeEnum getComponentType() {
    return componentType;
  }

  public void setComponentType(ComponentTypeEnum componentType) {
    this.componentType = componentType;
  }

  public VersionedConnection destination(ConnectableComponent destination) {
    this.destination = destination;
    return this;
  }

   /**
   * Get destination
   * @return destination
  **/
  @Schema(description = "")
  public ConnectableComponent getDestination() {
    return destination;
  }

  public void setDestination(ConnectableComponent destination) {
    this.destination = destination;
  }

  public VersionedConnection flowFileExpiration(String flowFileExpiration) {
    this.flowFileExpiration = flowFileExpiration;
    return this;
  }

   /**
   * The amount of time a flow file may be in the flow before it will be automatically aged out of the flow. Once a flow file reaches this age it will be terminated from the flow the next time a processor attempts to start work on it.
   * @return flowFileExpiration
  **/
  @Schema(description = "The amount of time a flow file may be in the flow before it will be automatically aged out of the flow. Once a flow file reaches this age it will be terminated from the flow the next time a processor attempts to start work on it.")
  public String getFlowFileExpiration() {
    return flowFileExpiration;
  }

  public void setFlowFileExpiration(String flowFileExpiration) {
    this.flowFileExpiration = flowFileExpiration;
  }

  public VersionedConnection groupIdentifier(String groupIdentifier) {
    this.groupIdentifier = groupIdentifier;
    return this;
  }

   /**
   * The ID of the Process Group that this component belongs to
   * @return groupIdentifier
  **/
  @Schema(description = "The ID of the Process Group that this component belongs to")
  public String getGroupIdentifier() {
    return groupIdentifier;
  }

  public void setGroupIdentifier(String groupIdentifier) {
    this.groupIdentifier = groupIdentifier;
  }

  public VersionedConnection identifier(String identifier) {
    this.identifier = identifier;
    return this;
  }

   /**
   * The component&#x27;s unique identifier
   * @return identifier
  **/
  @Schema(description = "The component's unique identifier")
  public String getIdentifier() {
    return identifier;
  }

  public void setIdentifier(String identifier) {
    this.identifier = identifier;
  }

  public VersionedConnection instanceIdentifier(String instanceIdentifier) {
    this.instanceIdentifier = instanceIdentifier;
    return this;
  }

   /**
   * The instance ID of an existing component that is described by this VersionedComponent, or null if this is not mapped to an instantiated component
   * @return instanceIdentifier
  **/
  @Schema(description = "The instance ID of an existing component that is described by this VersionedComponent, or null if this is not mapped to an instantiated component")
  public String getInstanceIdentifier() {
    return instanceIdentifier;
  }

  public void setInstanceIdentifier(String instanceIdentifier) {
    this.instanceIdentifier = instanceIdentifier;
  }

  public VersionedConnection labelIndex(Integer labelIndex) {
    this.labelIndex = labelIndex;
    return this;
  }

   /**
   * The index of the bend point where to place the connection label.
   * @return labelIndex
  **/
  @Schema(description = "The index of the bend point where to place the connection label.")
  public Integer getLabelIndex() {
    return labelIndex;
  }

  public void setLabelIndex(Integer labelIndex) {
    this.labelIndex = labelIndex;
  }

  public VersionedConnection loadBalanceCompression(LoadBalanceCompressionEnum loadBalanceCompression) {
    this.loadBalanceCompression = loadBalanceCompression;
    return this;
  }

   /**
   * Whether or not compression should be used when transferring FlowFiles between nodes
   * @return loadBalanceCompression
  **/
  @Schema(description = "Whether or not compression should be used when transferring FlowFiles between nodes")
  public LoadBalanceCompressionEnum getLoadBalanceCompression() {
    return loadBalanceCompression;
  }

  public void setLoadBalanceCompression(LoadBalanceCompressionEnum loadBalanceCompression) {
    this.loadBalanceCompression = loadBalanceCompression;
  }

  public VersionedConnection loadBalanceStrategy(LoadBalanceStrategyEnum loadBalanceStrategy) {
    this.loadBalanceStrategy = loadBalanceStrategy;
    return this;
  }

   /**
   * The Strategy to use for load balancing data across the cluster, or null, if no Load Balance Strategy has been specified.
   * @return loadBalanceStrategy
  **/
  @Schema(description = "The Strategy to use for load balancing data across the cluster, or null, if no Load Balance Strategy has been specified.")
  public LoadBalanceStrategyEnum getLoadBalanceStrategy() {
    return loadBalanceStrategy;
  }

  public void setLoadBalanceStrategy(LoadBalanceStrategyEnum loadBalanceStrategy) {
    this.loadBalanceStrategy = loadBalanceStrategy;
  }

  public VersionedConnection name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The component&#x27;s name
   * @return name
  **/
  @Schema(description = "The component's name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public VersionedConnection partitioningAttribute(String partitioningAttribute) {
    this.partitioningAttribute = partitioningAttribute;
    return this;
  }

   /**
   * The attribute to use for partitioning data as it is load balanced across the cluster. If the Load Balance Strategy is configured to use PARTITION_BY_ATTRIBUTE, the value returned by this method is the name of the FlowFile Attribute that will be used to determine which node in the cluster should receive a given FlowFile. If the Load Balance Strategy is unset or is set to any other value, the Partitioning Attribute has no effect.
   * @return partitioningAttribute
  **/
  @Schema(description = "The attribute to use for partitioning data as it is load balanced across the cluster. If the Load Balance Strategy is configured to use PARTITION_BY_ATTRIBUTE, the value returned by this method is the name of the FlowFile Attribute that will be used to determine which node in the cluster should receive a given FlowFile. If the Load Balance Strategy is unset or is set to any other value, the Partitioning Attribute has no effect.")
  public String getPartitioningAttribute() {
    return partitioningAttribute;
  }

  public void setPartitioningAttribute(String partitioningAttribute) {
    this.partitioningAttribute = partitioningAttribute;
  }

  public VersionedConnection position(Position position) {
    this.position = position;
    return this;
  }

   /**
   * Get position
   * @return position
  **/
  @Schema(description = "")
  public Position getPosition() {
    return position;
  }

  public void setPosition(Position position) {
    this.position = position;
  }

  public VersionedConnection prioritizers(List<String> prioritizers) {
    this.prioritizers = prioritizers;
    return this;
  }

  public VersionedConnection addPrioritizersItem(String prioritizersItem) {
    if (this.prioritizers == null) {
      this.prioritizers = new ArrayList<>();
    }
    this.prioritizers.add(prioritizersItem);
    return this;
  }

   /**
   * The comparators used to prioritize the queue.
   * @return prioritizers
  **/
  @Schema(description = "The comparators used to prioritize the queue.")
  public List<String> getPrioritizers() {
    return prioritizers;
  }

  public void setPrioritizers(List<String> prioritizers) {
    this.prioritizers = prioritizers;
  }

  public VersionedConnection selectedRelationships(List<String> selectedRelationships) {
    this.selectedRelationships = selectedRelationships;
    return this;
  }

  public VersionedConnection addSelectedRelationshipsItem(String selectedRelationshipsItem) {
    if (this.selectedRelationships == null) {
      this.selectedRelationships = new ArrayList<>();
    }
    this.selectedRelationships.add(selectedRelationshipsItem);
    return this;
  }

   /**
   * The selected relationship that comprise the connection.
   * @return selectedRelationships
  **/
  @Schema(description = "The selected relationship that comprise the connection.")
  public List<String> getSelectedRelationships() {
    return selectedRelationships;
  }

  public void setSelectedRelationships(List<String> selectedRelationships) {
    this.selectedRelationships = selectedRelationships;
  }

  public VersionedConnection source(ConnectableComponent source) {
    this.source = source;
    return this;
  }

   /**
   * Get source
   * @return source
  **/
  @Schema(description = "")
  public ConnectableComponent getSource() {
    return source;
  }

  public void setSource(ConnectableComponent source) {
    this.source = source;
  }

  public VersionedConnection zIndex(Long zIndex) {
    this.zIndex = zIndex;
    return this;
  }

   /**
   * The z index of the connection.
   * @return zIndex
  **/
  @Schema(description = "The z index of the connection.")
  public Long getZIndex() {
    return zIndex;
  }

  public void setZIndex(Long zIndex) {
    this.zIndex = zIndex;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VersionedConnection versionedConnection = (VersionedConnection) o;
    return Objects.equals(this.backPressureDataSizeThreshold, versionedConnection.backPressureDataSizeThreshold) &&
        Objects.equals(this.backPressureObjectThreshold, versionedConnection.backPressureObjectThreshold) &&
        Objects.equals(this.bends, versionedConnection.bends) &&
        Objects.equals(this.comments, versionedConnection.comments) &&
        Objects.equals(this.componentType, versionedConnection.componentType) &&
        Objects.equals(this.destination, versionedConnection.destination) &&
        Objects.equals(this.flowFileExpiration, versionedConnection.flowFileExpiration) &&
        Objects.equals(this.groupIdentifier, versionedConnection.groupIdentifier) &&
        Objects.equals(this.identifier, versionedConnection.identifier) &&
        Objects.equals(this.instanceIdentifier, versionedConnection.instanceIdentifier) &&
        Objects.equals(this.labelIndex, versionedConnection.labelIndex) &&
        Objects.equals(this.loadBalanceCompression, versionedConnection.loadBalanceCompression) &&
        Objects.equals(this.loadBalanceStrategy, versionedConnection.loadBalanceStrategy) &&
        Objects.equals(this.name, versionedConnection.name) &&
        Objects.equals(this.partitioningAttribute, versionedConnection.partitioningAttribute) &&
        Objects.equals(this.position, versionedConnection.position) &&
        Objects.equals(this.prioritizers, versionedConnection.prioritizers) &&
        Objects.equals(this.selectedRelationships, versionedConnection.selectedRelationships) &&
        Objects.equals(this.source, versionedConnection.source) &&
        Objects.equals(this.zIndex, versionedConnection.zIndex);
  }

  @Override
  public int hashCode() {
    return Objects.hash(backPressureDataSizeThreshold, backPressureObjectThreshold, bends, comments, componentType, destination, flowFileExpiration, groupIdentifier, identifier, instanceIdentifier, labelIndex, loadBalanceCompression, loadBalanceStrategy, name, partitioningAttribute, position, prioritizers, selectedRelationships, source, zIndex);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VersionedConnection {\n");
    
    sb.append("    backPressureDataSizeThreshold: ").append(toIndentedString(backPressureDataSizeThreshold)).append("\n");
    sb.append("    backPressureObjectThreshold: ").append(toIndentedString(backPressureObjectThreshold)).append("\n");
    sb.append("    bends: ").append(toIndentedString(bends)).append("\n");
    sb.append("    comments: ").append(toIndentedString(comments)).append("\n");
    sb.append("    componentType: ").append(toIndentedString(componentType)).append("\n");
    sb.append("    destination: ").append(toIndentedString(destination)).append("\n");
    sb.append("    flowFileExpiration: ").append(toIndentedString(flowFileExpiration)).append("\n");
    sb.append("    groupIdentifier: ").append(toIndentedString(groupIdentifier)).append("\n");
    sb.append("    identifier: ").append(toIndentedString(identifier)).append("\n");
    sb.append("    instanceIdentifier: ").append(toIndentedString(instanceIdentifier)).append("\n");
    sb.append("    labelIndex: ").append(toIndentedString(labelIndex)).append("\n");
    sb.append("    loadBalanceCompression: ").append(toIndentedString(loadBalanceCompression)).append("\n");
    sb.append("    loadBalanceStrategy: ").append(toIndentedString(loadBalanceStrategy)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    partitioningAttribute: ").append(toIndentedString(partitioningAttribute)).append("\n");
    sb.append("    position: ").append(toIndentedString(position)).append("\n");
    sb.append("    prioritizers: ").append(toIndentedString(prioritizers)).append("\n");
    sb.append("    selectedRelationships: ").append(toIndentedString(selectedRelationships)).append("\n");
    sb.append("    source: ").append(toIndentedString(source)).append("\n");
    sb.append("    zIndex: ").append(toIndentedString(zIndex)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
