/*
 * Apache NiFi REST API
 * REST API definition for Apache NiFi web services
 *
 * OpenAPI spec version: 2.4.0
 * Contact: dev@nifi.apache.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.apache.nifi.api.toolkit.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
/**
 * Predictions, if available, for this connection (null if not available)
 */
@Schema(description = "Predictions, if available, for this connection (null if not available)")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2025-09-03T13:15:23.252321740+05:30[Asia/Kolkata]")

public class ConnectionStatusPredictionsSnapshotDTO {
  @JsonProperty("predictedBytesAtNextInterval")
  private Long predictedBytesAtNextInterval = null;

  @JsonProperty("predictedCountAtNextInterval")
  private Integer predictedCountAtNextInterval = null;

  @JsonProperty("predictedMillisUntilBytesBackpressure")
  private Long predictedMillisUntilBytesBackpressure = null;

  @JsonProperty("predictedMillisUntilCountBackpressure")
  private Long predictedMillisUntilCountBackpressure = null;

  @JsonProperty("predictedPercentBytes")
  private Integer predictedPercentBytes = null;

  @JsonProperty("predictedPercentCount")
  private Integer predictedPercentCount = null;

  @JsonProperty("predictionIntervalSeconds")
  private Integer predictionIntervalSeconds = null;

  public ConnectionStatusPredictionsSnapshotDTO predictedBytesAtNextInterval(Long predictedBytesAtNextInterval) {
    this.predictedBytesAtNextInterval = predictedBytesAtNextInterval;
    return this;
  }

   /**
   * The predicted total number of bytes in the queue at the next configured interval.
   * @return predictedBytesAtNextInterval
  **/
  @Schema(description = "The predicted total number of bytes in the queue at the next configured interval.")
  public Long getPredictedBytesAtNextInterval() {
    return predictedBytesAtNextInterval;
  }

  public void setPredictedBytesAtNextInterval(Long predictedBytesAtNextInterval) {
    this.predictedBytesAtNextInterval = predictedBytesAtNextInterval;
  }

  public ConnectionStatusPredictionsSnapshotDTO predictedCountAtNextInterval(Integer predictedCountAtNextInterval) {
    this.predictedCountAtNextInterval = predictedCountAtNextInterval;
    return this;
  }

   /**
   * The predicted number of queued objects at the next configured interval.
   * @return predictedCountAtNextInterval
  **/
  @Schema(description = "The predicted number of queued objects at the next configured interval.")
  public Integer getPredictedCountAtNextInterval() {
    return predictedCountAtNextInterval;
  }

  public void setPredictedCountAtNextInterval(Integer predictedCountAtNextInterval) {
    this.predictedCountAtNextInterval = predictedCountAtNextInterval;
  }

  public ConnectionStatusPredictionsSnapshotDTO predictedMillisUntilBytesBackpressure(Long predictedMillisUntilBytesBackpressure) {
    this.predictedMillisUntilBytesBackpressure = predictedMillisUntilBytesBackpressure;
    return this;
  }

   /**
   * The predicted number of milliseconds before the connection will have backpressure applied, based on the total number of bytes in the queue.
   * @return predictedMillisUntilBytesBackpressure
  **/
  @Schema(description = "The predicted number of milliseconds before the connection will have backpressure applied, based on the total number of bytes in the queue.")
  public Long getPredictedMillisUntilBytesBackpressure() {
    return predictedMillisUntilBytesBackpressure;
  }

  public void setPredictedMillisUntilBytesBackpressure(Long predictedMillisUntilBytesBackpressure) {
    this.predictedMillisUntilBytesBackpressure = predictedMillisUntilBytesBackpressure;
  }

  public ConnectionStatusPredictionsSnapshotDTO predictedMillisUntilCountBackpressure(Long predictedMillisUntilCountBackpressure) {
    this.predictedMillisUntilCountBackpressure = predictedMillisUntilCountBackpressure;
    return this;
  }

   /**
   * The predicted number of milliseconds before the connection will have backpressure applied, based on the queued count.
   * @return predictedMillisUntilCountBackpressure
  **/
  @Schema(description = "The predicted number of milliseconds before the connection will have backpressure applied, based on the queued count.")
  public Long getPredictedMillisUntilCountBackpressure() {
    return predictedMillisUntilCountBackpressure;
  }

  public void setPredictedMillisUntilCountBackpressure(Long predictedMillisUntilCountBackpressure) {
    this.predictedMillisUntilCountBackpressure = predictedMillisUntilCountBackpressure;
  }

  public ConnectionStatusPredictionsSnapshotDTO predictedPercentBytes(Integer predictedPercentBytes) {
    this.predictedPercentBytes = predictedPercentBytes;
    return this;
  }

   /**
   * Predicted connection percent use regarding queued flow files size and backpressure threshold if configured.
   * @return predictedPercentBytes
  **/
  @Schema(description = "Predicted connection percent use regarding queued flow files size and backpressure threshold if configured.")
  public Integer getPredictedPercentBytes() {
    return predictedPercentBytes;
  }

  public void setPredictedPercentBytes(Integer predictedPercentBytes) {
    this.predictedPercentBytes = predictedPercentBytes;
  }

  public ConnectionStatusPredictionsSnapshotDTO predictedPercentCount(Integer predictedPercentCount) {
    this.predictedPercentCount = predictedPercentCount;
    return this;
  }

   /**
   * Predicted connection percent use regarding queued flow files count and backpressure threshold if configured.
   * @return predictedPercentCount
  **/
  @Schema(description = "Predicted connection percent use regarding queued flow files count and backpressure threshold if configured.")
  public Integer getPredictedPercentCount() {
    return predictedPercentCount;
  }

  public void setPredictedPercentCount(Integer predictedPercentCount) {
    this.predictedPercentCount = predictedPercentCount;
  }

  public ConnectionStatusPredictionsSnapshotDTO predictionIntervalSeconds(Integer predictionIntervalSeconds) {
    this.predictionIntervalSeconds = predictionIntervalSeconds;
    return this;
  }

   /**
   * The configured interval (in seconds) for predicting connection queue count and size (and percent usage).
   * @return predictionIntervalSeconds
  **/
  @Schema(description = "The configured interval (in seconds) for predicting connection queue count and size (and percent usage).")
  public Integer getPredictionIntervalSeconds() {
    return predictionIntervalSeconds;
  }

  public void setPredictionIntervalSeconds(Integer predictionIntervalSeconds) {
    this.predictionIntervalSeconds = predictionIntervalSeconds;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ConnectionStatusPredictionsSnapshotDTO connectionStatusPredictionsSnapshotDTO = (ConnectionStatusPredictionsSnapshotDTO) o;
    return Objects.equals(this.predictedBytesAtNextInterval, connectionStatusPredictionsSnapshotDTO.predictedBytesAtNextInterval) &&
        Objects.equals(this.predictedCountAtNextInterval, connectionStatusPredictionsSnapshotDTO.predictedCountAtNextInterval) &&
        Objects.equals(this.predictedMillisUntilBytesBackpressure, connectionStatusPredictionsSnapshotDTO.predictedMillisUntilBytesBackpressure) &&
        Objects.equals(this.predictedMillisUntilCountBackpressure, connectionStatusPredictionsSnapshotDTO.predictedMillisUntilCountBackpressure) &&
        Objects.equals(this.predictedPercentBytes, connectionStatusPredictionsSnapshotDTO.predictedPercentBytes) &&
        Objects.equals(this.predictedPercentCount, connectionStatusPredictionsSnapshotDTO.predictedPercentCount) &&
        Objects.equals(this.predictionIntervalSeconds, connectionStatusPredictionsSnapshotDTO.predictionIntervalSeconds);
  }

  @Override
  public int hashCode() {
    return Objects.hash(predictedBytesAtNextInterval, predictedCountAtNextInterval, predictedMillisUntilBytesBackpressure, predictedMillisUntilCountBackpressure, predictedPercentBytes, predictedPercentCount, predictionIntervalSeconds);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ConnectionStatusPredictionsSnapshotDTO {\n");
    
    sb.append("    predictedBytesAtNextInterval: ").append(toIndentedString(predictedBytesAtNextInterval)).append("\n");
    sb.append("    predictedCountAtNextInterval: ").append(toIndentedString(predictedCountAtNextInterval)).append("\n");
    sb.append("    predictedMillisUntilBytesBackpressure: ").append(toIndentedString(predictedMillisUntilBytesBackpressure)).append("\n");
    sb.append("    predictedMillisUntilCountBackpressure: ").append(toIndentedString(predictedMillisUntilCountBackpressure)).append("\n");
    sb.append("    predictedPercentBytes: ").append(toIndentedString(predictedPercentBytes)).append("\n");
    sb.append("    predictedPercentCount: ").append(toIndentedString(predictedPercentCount)).append("\n");
    sb.append("    predictionIntervalSeconds: ").append(toIndentedString(predictionIntervalSeconds)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
