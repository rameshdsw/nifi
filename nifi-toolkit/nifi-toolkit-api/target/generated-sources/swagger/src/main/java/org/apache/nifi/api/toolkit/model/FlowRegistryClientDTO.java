/*
 * Apache NiFi REST API
 * REST API definition for Apache NiFi web services
 *
 * OpenAPI spec version: 2.4.0
 * Contact: dev@nifi.apache.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.apache.nifi.api.toolkit.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.nifi.api.toolkit.model.BundleDTO;
import org.apache.nifi.api.toolkit.model.PropertyDescriptorDTO;
/**
 * FlowRegistryClientDTO
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2025-09-03T13:15:23.252321740+05:30[Asia/Kolkata]")

public class FlowRegistryClientDTO {
  @JsonProperty("annotationData")
  private String annotationData = null;

  @JsonProperty("bundle")
  private BundleDTO bundle = null;

  @JsonProperty("deprecated")
  private Boolean deprecated = null;

  @JsonProperty("description")
  private String description = null;

  @JsonProperty("descriptors")
  private Map<String, PropertyDescriptorDTO> descriptors = null;

  @JsonProperty("extensionMissing")
  private Boolean extensionMissing = null;

  @JsonProperty("id")
  private String id = null;

  @JsonProperty("multipleVersionsAvailable")
  private Boolean multipleVersionsAvailable = null;

  @JsonProperty("name")
  private String name = null;

  @JsonProperty("properties")
  private Map<String, String> properties = null;

  @JsonProperty("restricted")
  private Boolean restricted = null;

  @JsonProperty("sensitiveDynamicPropertyNames")
  private List<String> sensitiveDynamicPropertyNames = null;

  @JsonProperty("supportsBranching")
  private Boolean supportsBranching = null;

  @JsonProperty("supportsSensitiveDynamicProperties")
  private Boolean supportsSensitiveDynamicProperties = null;

  @JsonProperty("type")
  private String type = null;

  @JsonProperty("validationErrors")
  private List<String> validationErrors = null;

  /**
   * Indicates whether the Registry Client is valid, invalid, or still in the process of validating (i.e., it is unknown whether or not the Registry Client is valid)
   */
  public enum ValidationStatusEnum {
    VALID("VALID"),
    INVALID("INVALID"),
    VALIDATING("VALIDATING");

    private String value;

    ValidationStatusEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static ValidationStatusEnum fromValue(String input) {
      for (ValidationStatusEnum b : ValidationStatusEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("validationStatus")
  private ValidationStatusEnum validationStatus = null;

  public FlowRegistryClientDTO annotationData(String annotationData) {
    this.annotationData = annotationData;
    return this;
  }

   /**
   * The annotation data for the registry client. This is how the custom UI relays configuration to the registry client.
   * @return annotationData
  **/
  @Schema(description = "The annotation data for the registry client. This is how the custom UI relays configuration to the registry client.")
  public String getAnnotationData() {
    return annotationData;
  }

  public void setAnnotationData(String annotationData) {
    this.annotationData = annotationData;
  }

  public FlowRegistryClientDTO bundle(BundleDTO bundle) {
    this.bundle = bundle;
    return this;
  }

   /**
   * Get bundle
   * @return bundle
  **/
  @Schema(description = "")
  public BundleDTO getBundle() {
    return bundle;
  }

  public void setBundle(BundleDTO bundle) {
    this.bundle = bundle;
  }

  public FlowRegistryClientDTO deprecated(Boolean deprecated) {
    this.deprecated = deprecated;
    return this;
  }

   /**
   * Whether the registry client has been deprecated.
   * @return deprecated
  **/
  @Schema(description = "Whether the registry client has been deprecated.")
  public Boolean isDeprecated() {
    return deprecated;
  }

  public void setDeprecated(Boolean deprecated) {
    this.deprecated = deprecated;
  }

  public FlowRegistryClientDTO description(String description) {
    this.description = description;
    return this;
  }

   /**
   * The registry description
   * @return description
  **/
  @Schema(description = "The registry description")
  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public FlowRegistryClientDTO descriptors(Map<String, PropertyDescriptorDTO> descriptors) {
    this.descriptors = descriptors;
    return this;
  }

  public FlowRegistryClientDTO putDescriptorsItem(String key, PropertyDescriptorDTO descriptorsItem) {
    if (this.descriptors == null) {
      this.descriptors = new HashMap<>();
    }
    this.descriptors.put(key, descriptorsItem);
    return this;
  }

   /**
   * The descriptors for the registry client properties.
   * @return descriptors
  **/
  @Schema(description = "The descriptors for the registry client properties.")
  public Map<String, PropertyDescriptorDTO> getDescriptors() {
    return descriptors;
  }

  public void setDescriptors(Map<String, PropertyDescriptorDTO> descriptors) {
    this.descriptors = descriptors;
  }

  public FlowRegistryClientDTO extensionMissing(Boolean extensionMissing) {
    this.extensionMissing = extensionMissing;
    return this;
  }

   /**
   * Whether the underlying extension is missing.
   * @return extensionMissing
  **/
  @Schema(description = "Whether the underlying extension is missing.")
  public Boolean isExtensionMissing() {
    return extensionMissing;
  }

  public void setExtensionMissing(Boolean extensionMissing) {
    this.extensionMissing = extensionMissing;
  }

  public FlowRegistryClientDTO id(String id) {
    this.id = id;
    return this;
  }

   /**
   * The registry identifier
   * @return id
  **/
  @Schema(description = "The registry identifier")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public FlowRegistryClientDTO multipleVersionsAvailable(Boolean multipleVersionsAvailable) {
    this.multipleVersionsAvailable = multipleVersionsAvailable;
    return this;
  }

   /**
   * Whether the flow registry client has multiple versions available.
   * @return multipleVersionsAvailable
  **/
  @Schema(description = "Whether the flow registry client has multiple versions available.")
  public Boolean isMultipleVersionsAvailable() {
    return multipleVersionsAvailable;
  }

  public void setMultipleVersionsAvailable(Boolean multipleVersionsAvailable) {
    this.multipleVersionsAvailable = multipleVersionsAvailable;
  }

  public FlowRegistryClientDTO name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The registry name
   * @return name
  **/
  @Schema(description = "The registry name")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

  public FlowRegistryClientDTO properties(Map<String, String> properties) {
    this.properties = properties;
    return this;
  }

  public FlowRegistryClientDTO putPropertiesItem(String key, String propertiesItem) {
    if (this.properties == null) {
      this.properties = new HashMap<>();
    }
    this.properties.put(key, propertiesItem);
    return this;
  }

   /**
   * The properties of the registry client.
   * @return properties
  **/
  @Schema(description = "The properties of the registry client.")
  public Map<String, String> getProperties() {
    return properties;
  }

  public void setProperties(Map<String, String> properties) {
    this.properties = properties;
  }

  public FlowRegistryClientDTO restricted(Boolean restricted) {
    this.restricted = restricted;
    return this;
  }

   /**
   * Whether the registry client requires elevated privileges.
   * @return restricted
  **/
  @Schema(description = "Whether the registry client requires elevated privileges.")
  public Boolean isRestricted() {
    return restricted;
  }

  public void setRestricted(Boolean restricted) {
    this.restricted = restricted;
  }

  public FlowRegistryClientDTO sensitiveDynamicPropertyNames(List<String> sensitiveDynamicPropertyNames) {
    this.sensitiveDynamicPropertyNames = sensitiveDynamicPropertyNames;
    return this;
  }

  public FlowRegistryClientDTO addSensitiveDynamicPropertyNamesItem(String sensitiveDynamicPropertyNamesItem) {
    if (this.sensitiveDynamicPropertyNames == null) {
      this.sensitiveDynamicPropertyNames = new ArrayList<>();
    }
    this.sensitiveDynamicPropertyNames.add(sensitiveDynamicPropertyNamesItem);
    return this;
  }

   /**
   * Set of sensitive dynamic property names
   * @return sensitiveDynamicPropertyNames
  **/
  @Schema(description = "Set of sensitive dynamic property names")
  public List<String> getSensitiveDynamicPropertyNames() {
    return sensitiveDynamicPropertyNames;
  }

  public void setSensitiveDynamicPropertyNames(List<String> sensitiveDynamicPropertyNames) {
    this.sensitiveDynamicPropertyNames = sensitiveDynamicPropertyNames;
  }

  public FlowRegistryClientDTO supportsBranching(Boolean supportsBranching) {
    this.supportsBranching = supportsBranching;
    return this;
  }

   /**
   * Whether the registry client supports branching.
   * @return supportsBranching
  **/
  @Schema(description = "Whether the registry client supports branching.")
  public Boolean isSupportsBranching() {
    return supportsBranching;
  }

  public void setSupportsBranching(Boolean supportsBranching) {
    this.supportsBranching = supportsBranching;
  }

  public FlowRegistryClientDTO supportsSensitiveDynamicProperties(Boolean supportsSensitiveDynamicProperties) {
    this.supportsSensitiveDynamicProperties = supportsSensitiveDynamicProperties;
    return this;
  }

   /**
   * Whether the registry client supports sensitive dynamic properties.
   * @return supportsSensitiveDynamicProperties
  **/
  @Schema(description = "Whether the registry client supports sensitive dynamic properties.")
  public Boolean isSupportsSensitiveDynamicProperties() {
    return supportsSensitiveDynamicProperties;
  }

  public void setSupportsSensitiveDynamicProperties(Boolean supportsSensitiveDynamicProperties) {
    this.supportsSensitiveDynamicProperties = supportsSensitiveDynamicProperties;
  }

  public FlowRegistryClientDTO type(String type) {
    this.type = type;
    return this;
  }

   /**
   * The type of the registry client.
   * @return type
  **/
  @Schema(description = "The type of the registry client.")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public FlowRegistryClientDTO validationErrors(List<String> validationErrors) {
    this.validationErrors = validationErrors;
    return this;
  }

  public FlowRegistryClientDTO addValidationErrorsItem(String validationErrorsItem) {
    if (this.validationErrors == null) {
      this.validationErrors = new ArrayList<>();
    }
    this.validationErrors.add(validationErrorsItem);
    return this;
  }

   /**
   * Gets the validation errors from the registry client. These validation errors represent the problems with the registry client that must be resolved before it can be used for interacting with the flow registry.
   * @return validationErrors
  **/
  @Schema(description = "Gets the validation errors from the registry client. These validation errors represent the problems with the registry client that must be resolved before it can be used for interacting with the flow registry.")
  public List<String> getValidationErrors() {
    return validationErrors;
  }

  public void setValidationErrors(List<String> validationErrors) {
    this.validationErrors = validationErrors;
  }

   /**
   * Indicates whether the Registry Client is valid, invalid, or still in the process of validating (i.e., it is unknown whether or not the Registry Client is valid)
   * @return validationStatus
  **/
  @Schema(description = "Indicates whether the Registry Client is valid, invalid, or still in the process of validating (i.e., it is unknown whether or not the Registry Client is valid)")
  public ValidationStatusEnum getValidationStatus() {
    return validationStatus;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FlowRegistryClientDTO flowRegistryClientDTO = (FlowRegistryClientDTO) o;
    return Objects.equals(this.annotationData, flowRegistryClientDTO.annotationData) &&
        Objects.equals(this.bundle, flowRegistryClientDTO.bundle) &&
        Objects.equals(this.deprecated, flowRegistryClientDTO.deprecated) &&
        Objects.equals(this.description, flowRegistryClientDTO.description) &&
        Objects.equals(this.descriptors, flowRegistryClientDTO.descriptors) &&
        Objects.equals(this.extensionMissing, flowRegistryClientDTO.extensionMissing) &&
        Objects.equals(this.id, flowRegistryClientDTO.id) &&
        Objects.equals(this.multipleVersionsAvailable, flowRegistryClientDTO.multipleVersionsAvailable) &&
        Objects.equals(this.name, flowRegistryClientDTO.name) &&
        Objects.equals(this.properties, flowRegistryClientDTO.properties) &&
        Objects.equals(this.restricted, flowRegistryClientDTO.restricted) &&
        Objects.equals(this.sensitiveDynamicPropertyNames, flowRegistryClientDTO.sensitiveDynamicPropertyNames) &&
        Objects.equals(this.supportsBranching, flowRegistryClientDTO.supportsBranching) &&
        Objects.equals(this.supportsSensitiveDynamicProperties, flowRegistryClientDTO.supportsSensitiveDynamicProperties) &&
        Objects.equals(this.type, flowRegistryClientDTO.type) &&
        Objects.equals(this.validationErrors, flowRegistryClientDTO.validationErrors) &&
        Objects.equals(this.validationStatus, flowRegistryClientDTO.validationStatus);
  }

  @Override
  public int hashCode() {
    return Objects.hash(annotationData, bundle, deprecated, description, descriptors, extensionMissing, id, multipleVersionsAvailable, name, properties, restricted, sensitiveDynamicPropertyNames, supportsBranching, supportsSensitiveDynamicProperties, type, validationErrors, validationStatus);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FlowRegistryClientDTO {\n");
    
    sb.append("    annotationData: ").append(toIndentedString(annotationData)).append("\n");
    sb.append("    bundle: ").append(toIndentedString(bundle)).append("\n");
    sb.append("    deprecated: ").append(toIndentedString(deprecated)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    descriptors: ").append(toIndentedString(descriptors)).append("\n");
    sb.append("    extensionMissing: ").append(toIndentedString(extensionMissing)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    multipleVersionsAvailable: ").append(toIndentedString(multipleVersionsAvailable)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    restricted: ").append(toIndentedString(restricted)).append("\n");
    sb.append("    sensitiveDynamicPropertyNames: ").append(toIndentedString(sensitiveDynamicPropertyNames)).append("\n");
    sb.append("    supportsBranching: ").append(toIndentedString(supportsBranching)).append("\n");
    sb.append("    supportsSensitiveDynamicProperties: ").append(toIndentedString(supportsSensitiveDynamicProperties)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    validationErrors: ").append(toIndentedString(validationErrors)).append("\n");
    sb.append("    validationStatus: ").append(toIndentedString(validationStatus)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
