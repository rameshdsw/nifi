/*
 * Apache NiFi REST API
 * REST API definition for Apache NiFi web services
 *
 * OpenAPI spec version: 2.4.0
 * Contact: dev@nifi.apache.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.apache.nifi.api.toolkit.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.apache.nifi.api.toolkit.model.Attribute;
import org.apache.nifi.api.toolkit.model.BuildInfo;
import org.apache.nifi.api.toolkit.model.DefinedType;
import org.apache.nifi.api.toolkit.model.DynamicProperty;
import org.apache.nifi.api.toolkit.model.DynamicRelationship;
import org.apache.nifi.api.toolkit.model.MultiProcessorUseCase;
import org.apache.nifi.api.toolkit.model.PropertyDescriptor;
import org.apache.nifi.api.toolkit.model.Relationship;
import org.apache.nifi.api.toolkit.model.Restriction;
import org.apache.nifi.api.toolkit.model.Stateful;
import org.apache.nifi.api.toolkit.model.SystemResourceConsideration;
import org.apache.nifi.api.toolkit.model.UseCase;
/**
 * Processors provided in this bundle
 */
@Schema(description = "Processors provided in this bundle")
@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2025-09-03T13:15:23.252321740+05:30[Asia/Kolkata]")

public class ProcessorDefinition {
  @JsonProperty("additionalDetails")
  private Boolean additionalDetails = null;

  @JsonProperty("artifact")
  private String artifact = null;

  @JsonProperty("buildInfo")
  private BuildInfo buildInfo = null;

  @JsonProperty("defaultBulletinLevel")
  private String defaultBulletinLevel = null;

  @JsonProperty("defaultConcurrentTasksBySchedulingStrategy")
  private Map<String, Integer> defaultConcurrentTasksBySchedulingStrategy = null;

  @JsonProperty("defaultPenaltyDuration")
  private String defaultPenaltyDuration = null;

  @JsonProperty("defaultSchedulingPeriodBySchedulingStrategy")
  private Map<String, String> defaultSchedulingPeriodBySchedulingStrategy = null;

  @JsonProperty("defaultSchedulingStrategy")
  private String defaultSchedulingStrategy = null;

  @JsonProperty("defaultYieldDuration")
  private String defaultYieldDuration = null;

  @JsonProperty("deprecated")
  private Boolean deprecated = null;

  @JsonProperty("deprecationAlternatives")
  private List<String> deprecationAlternatives = null;

  @JsonProperty("deprecationReason")
  private String deprecationReason = null;

  @JsonProperty("dynamicProperties")
  private List<DynamicProperty> dynamicProperties = null;

  @JsonProperty("dynamicRelationship")
  private DynamicRelationship dynamicRelationship = null;

  @JsonProperty("explicitRestrictions")
  private List<Restriction> explicitRestrictions = null;

  @JsonProperty("group")
  private String group = null;

  /**
   * Any input requirements this processor has.
   */
  public enum InputRequirementEnum {
    REQUIRED("INPUT_REQUIRED"),
    ALLOWED("INPUT_ALLOWED"),
    FORBIDDEN("INPUT_FORBIDDEN");

    private String value;

    InputRequirementEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static InputRequirementEnum fromValue(String input) {
      for (InputRequirementEnum b : InputRequirementEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("inputRequirement")
  private InputRequirementEnum inputRequirement = null;

  @JsonProperty("multiProcessorUseCases")
  private List<MultiProcessorUseCase> multiProcessorUseCases = null;

  @JsonProperty("primaryNodeOnly")
  private Boolean primaryNodeOnly = null;

  @JsonProperty("propertyDescriptors")
  private Map<String, PropertyDescriptor> propertyDescriptors = null;

  @JsonProperty("providedApiImplementations")
  private List<DefinedType> providedApiImplementations = null;

  @JsonProperty("readsAttributes")
  private List<Attribute> readsAttributes = null;

  @JsonProperty("restricted")
  private Boolean restricted = null;

  @JsonProperty("restrictedExplanation")
  private String restrictedExplanation = null;

  @JsonProperty("seeAlso")
  private List<String> seeAlso = null;

  @JsonProperty("sideEffectFree")
  private Boolean sideEffectFree = null;

  @JsonProperty("stateful")
  private Stateful stateful = null;

  @JsonProperty("supportedRelationships")
  private List<Relationship> supportedRelationships = null;

  @JsonProperty("supportedSchedulingStrategies")
  private List<String> supportedSchedulingStrategies = null;

  @JsonProperty("supportsBatching")
  private Boolean supportsBatching = null;

  @JsonProperty("supportsDynamicProperties")
  private Boolean supportsDynamicProperties = null;

  @JsonProperty("supportsDynamicRelationships")
  private Boolean supportsDynamicRelationships = null;

  @JsonProperty("supportsSensitiveDynamicProperties")
  private Boolean supportsSensitiveDynamicProperties = null;

  @JsonProperty("systemResourceConsiderations")
  private List<SystemResourceConsideration> systemResourceConsiderations = null;

  @JsonProperty("tags")
  private List<String> tags = null;

  @JsonProperty("triggerSerially")
  private Boolean triggerSerially = null;

  @JsonProperty("triggerWhenAnyDestinationAvailable")
  private Boolean triggerWhenAnyDestinationAvailable = null;

  @JsonProperty("triggerWhenEmpty")
  private Boolean triggerWhenEmpty = null;

  @JsonProperty("type")
  private String type = null;

  @JsonProperty("typeDescription")
  private String typeDescription = null;

  @JsonProperty("useCases")
  private List<UseCase> useCases = null;

  @JsonProperty("version")
  private String version = null;

  @JsonProperty("writesAttributes")
  private List<Attribute> writesAttributes = null;

  public ProcessorDefinition additionalDetails(Boolean additionalDetails) {
    this.additionalDetails = additionalDetails;
    return this;
  }

   /**
   * Indicates if the component has additional details documentation
   * @return additionalDetails
  **/
  @Schema(description = "Indicates if the component has additional details documentation")
  public Boolean isAdditionalDetails() {
    return additionalDetails;
  }

  public void setAdditionalDetails(Boolean additionalDetails) {
    this.additionalDetails = additionalDetails;
  }

  public ProcessorDefinition artifact(String artifact) {
    this.artifact = artifact;
    return this;
  }

   /**
   * The artifact name of the bundle that provides the referenced type.
   * @return artifact
  **/
  @Schema(description = "The artifact name of the bundle that provides the referenced type.")
  public String getArtifact() {
    return artifact;
  }

  public void setArtifact(String artifact) {
    this.artifact = artifact;
  }

  public ProcessorDefinition buildInfo(BuildInfo buildInfo) {
    this.buildInfo = buildInfo;
    return this;
  }

   /**
   * Get buildInfo
   * @return buildInfo
  **/
  @Schema(description = "")
  public BuildInfo getBuildInfo() {
    return buildInfo;
  }

  public void setBuildInfo(BuildInfo buildInfo) {
    this.buildInfo = buildInfo;
  }

  public ProcessorDefinition defaultBulletinLevel(String defaultBulletinLevel) {
    this.defaultBulletinLevel = defaultBulletinLevel;
    return this;
  }

   /**
   * The default bulletin level, such as WARN, INFO, DEBUG, etc.
   * @return defaultBulletinLevel
  **/
  @Schema(description = "The default bulletin level, such as WARN, INFO, DEBUG, etc.")
  public String getDefaultBulletinLevel() {
    return defaultBulletinLevel;
  }

  public void setDefaultBulletinLevel(String defaultBulletinLevel) {
    this.defaultBulletinLevel = defaultBulletinLevel;
  }

  public ProcessorDefinition defaultConcurrentTasksBySchedulingStrategy(Map<String, Integer> defaultConcurrentTasksBySchedulingStrategy) {
    this.defaultConcurrentTasksBySchedulingStrategy = defaultConcurrentTasksBySchedulingStrategy;
    return this;
  }

  public ProcessorDefinition putDefaultConcurrentTasksBySchedulingStrategyItem(String key, Integer defaultConcurrentTasksBySchedulingStrategyItem) {
    if (this.defaultConcurrentTasksBySchedulingStrategy == null) {
      this.defaultConcurrentTasksBySchedulingStrategy = new HashMap<>();
    }
    this.defaultConcurrentTasksBySchedulingStrategy.put(key, defaultConcurrentTasksBySchedulingStrategyItem);
    return this;
  }

   /**
   * The default concurrent tasks for each scheduling strategy.
   * @return defaultConcurrentTasksBySchedulingStrategy
  **/
  @Schema(description = "The default concurrent tasks for each scheduling strategy.")
  public Map<String, Integer> getDefaultConcurrentTasksBySchedulingStrategy() {
    return defaultConcurrentTasksBySchedulingStrategy;
  }

  public void setDefaultConcurrentTasksBySchedulingStrategy(Map<String, Integer> defaultConcurrentTasksBySchedulingStrategy) {
    this.defaultConcurrentTasksBySchedulingStrategy = defaultConcurrentTasksBySchedulingStrategy;
  }

  public ProcessorDefinition defaultPenaltyDuration(String defaultPenaltyDuration) {
    this.defaultPenaltyDuration = defaultPenaltyDuration;
    return this;
  }

   /**
   * The default penalty duration as a time period, such as \&quot;30 sec\&quot;.
   * @return defaultPenaltyDuration
  **/
  @Schema(description = "The default penalty duration as a time period, such as \"30 sec\".")
  public String getDefaultPenaltyDuration() {
    return defaultPenaltyDuration;
  }

  public void setDefaultPenaltyDuration(String defaultPenaltyDuration) {
    this.defaultPenaltyDuration = defaultPenaltyDuration;
  }

  public ProcessorDefinition defaultSchedulingPeriodBySchedulingStrategy(Map<String, String> defaultSchedulingPeriodBySchedulingStrategy) {
    this.defaultSchedulingPeriodBySchedulingStrategy = defaultSchedulingPeriodBySchedulingStrategy;
    return this;
  }

  public ProcessorDefinition putDefaultSchedulingPeriodBySchedulingStrategyItem(String key, String defaultSchedulingPeriodBySchedulingStrategyItem) {
    if (this.defaultSchedulingPeriodBySchedulingStrategy == null) {
      this.defaultSchedulingPeriodBySchedulingStrategy = new HashMap<>();
    }
    this.defaultSchedulingPeriodBySchedulingStrategy.put(key, defaultSchedulingPeriodBySchedulingStrategyItem);
    return this;
  }

   /**
   * The default scheduling period for each scheduling strategy. The scheduling period is expected to be a time period, such as \&quot;30 sec\&quot;.
   * @return defaultSchedulingPeriodBySchedulingStrategy
  **/
  @Schema(description = "The default scheduling period for each scheduling strategy. The scheduling period is expected to be a time period, such as \"30 sec\".")
  public Map<String, String> getDefaultSchedulingPeriodBySchedulingStrategy() {
    return defaultSchedulingPeriodBySchedulingStrategy;
  }

  public void setDefaultSchedulingPeriodBySchedulingStrategy(Map<String, String> defaultSchedulingPeriodBySchedulingStrategy) {
    this.defaultSchedulingPeriodBySchedulingStrategy = defaultSchedulingPeriodBySchedulingStrategy;
  }

  public ProcessorDefinition defaultSchedulingStrategy(String defaultSchedulingStrategy) {
    this.defaultSchedulingStrategy = defaultSchedulingStrategy;
    return this;
  }

   /**
   * The default scheduling strategy for the processor.
   * @return defaultSchedulingStrategy
  **/
  @Schema(description = "The default scheduling strategy for the processor.")
  public String getDefaultSchedulingStrategy() {
    return defaultSchedulingStrategy;
  }

  public void setDefaultSchedulingStrategy(String defaultSchedulingStrategy) {
    this.defaultSchedulingStrategy = defaultSchedulingStrategy;
  }

  public ProcessorDefinition defaultYieldDuration(String defaultYieldDuration) {
    this.defaultYieldDuration = defaultYieldDuration;
    return this;
  }

   /**
   * The default yield duration as a time period, such as \&quot;1 sec\&quot;.
   * @return defaultYieldDuration
  **/
  @Schema(description = "The default yield duration as a time period, such as \"1 sec\".")
  public String getDefaultYieldDuration() {
    return defaultYieldDuration;
  }

  public void setDefaultYieldDuration(String defaultYieldDuration) {
    this.defaultYieldDuration = defaultYieldDuration;
  }

  public ProcessorDefinition deprecated(Boolean deprecated) {
    this.deprecated = deprecated;
    return this;
  }

   /**
   * Whether or not the component has been deprecated
   * @return deprecated
  **/
  @Schema(description = "Whether or not the component has been deprecated")
  public Boolean isDeprecated() {
    return deprecated;
  }

  public void setDeprecated(Boolean deprecated) {
    this.deprecated = deprecated;
  }

  public ProcessorDefinition deprecationAlternatives(List<String> deprecationAlternatives) {
    this.deprecationAlternatives = deprecationAlternatives;
    return this;
  }

  public ProcessorDefinition addDeprecationAlternativesItem(String deprecationAlternativesItem) {
    if (this.deprecationAlternatives == null) {
      this.deprecationAlternatives = new ArrayList<>();
    }
    this.deprecationAlternatives.add(deprecationAlternativesItem);
    return this;
  }

   /**
   * If this component has been deprecated, this optional field provides alternatives to use
   * @return deprecationAlternatives
  **/
  @Schema(description = "If this component has been deprecated, this optional field provides alternatives to use")
  public List<String> getDeprecationAlternatives() {
    return deprecationAlternatives;
  }

  public void setDeprecationAlternatives(List<String> deprecationAlternatives) {
    this.deprecationAlternatives = deprecationAlternatives;
  }

  public ProcessorDefinition deprecationReason(String deprecationReason) {
    this.deprecationReason = deprecationReason;
    return this;
  }

   /**
   * If this component has been deprecated, this optional field can be used to provide an explanation
   * @return deprecationReason
  **/
  @Schema(description = "If this component has been deprecated, this optional field can be used to provide an explanation")
  public String getDeprecationReason() {
    return deprecationReason;
  }

  public void setDeprecationReason(String deprecationReason) {
    this.deprecationReason = deprecationReason;
  }

  public ProcessorDefinition dynamicProperties(List<DynamicProperty> dynamicProperties) {
    this.dynamicProperties = dynamicProperties;
    return this;
  }

  public ProcessorDefinition addDynamicPropertiesItem(DynamicProperty dynamicPropertiesItem) {
    if (this.dynamicProperties == null) {
      this.dynamicProperties = new ArrayList<>();
    }
    this.dynamicProperties.add(dynamicPropertiesItem);
    return this;
  }

   /**
   * Describes the dynamic properties supported by this component
   * @return dynamicProperties
  **/
  @Schema(description = "Describes the dynamic properties supported by this component")
  public List<DynamicProperty> getDynamicProperties() {
    return dynamicProperties;
  }

  public void setDynamicProperties(List<DynamicProperty> dynamicProperties) {
    this.dynamicProperties = dynamicProperties;
  }

  public ProcessorDefinition dynamicRelationship(DynamicRelationship dynamicRelationship) {
    this.dynamicRelationship = dynamicRelationship;
    return this;
  }

   /**
   * Get dynamicRelationship
   * @return dynamicRelationship
  **/
  @Schema(description = "")
  public DynamicRelationship getDynamicRelationship() {
    return dynamicRelationship;
  }

  public void setDynamicRelationship(DynamicRelationship dynamicRelationship) {
    this.dynamicRelationship = dynamicRelationship;
  }

  public ProcessorDefinition explicitRestrictions(List<Restriction> explicitRestrictions) {
    this.explicitRestrictions = explicitRestrictions;
    return this;
  }

  public ProcessorDefinition addExplicitRestrictionsItem(Restriction explicitRestrictionsItem) {
    if (this.explicitRestrictions == null) {
      this.explicitRestrictions = new ArrayList<>();
    }
    this.explicitRestrictions.add(explicitRestrictionsItem);
    return this;
  }

   /**
   * Explicit restrictions that indicate a require permission to use the component
   * @return explicitRestrictions
  **/
  @Schema(description = "Explicit restrictions that indicate a require permission to use the component")
  public List<Restriction> getExplicitRestrictions() {
    return explicitRestrictions;
  }

  public void setExplicitRestrictions(List<Restriction> explicitRestrictions) {
    this.explicitRestrictions = explicitRestrictions;
  }

  public ProcessorDefinition group(String group) {
    this.group = group;
    return this;
  }

   /**
   * The group name of the bundle that provides the referenced type.
   * @return group
  **/
  @Schema(description = "The group name of the bundle that provides the referenced type.")
  public String getGroup() {
    return group;
  }

  public void setGroup(String group) {
    this.group = group;
  }

  public ProcessorDefinition inputRequirement(InputRequirementEnum inputRequirement) {
    this.inputRequirement = inputRequirement;
    return this;
  }

   /**
   * Any input requirements this processor has.
   * @return inputRequirement
  **/
  @Schema(description = "Any input requirements this processor has.")
  public InputRequirementEnum getInputRequirement() {
    return inputRequirement;
  }

  public void setInputRequirement(InputRequirementEnum inputRequirement) {
    this.inputRequirement = inputRequirement;
  }

  public ProcessorDefinition multiProcessorUseCases(List<MultiProcessorUseCase> multiProcessorUseCases) {
    this.multiProcessorUseCases = multiProcessorUseCases;
    return this;
  }

  public ProcessorDefinition addMultiProcessorUseCasesItem(MultiProcessorUseCase multiProcessorUseCasesItem) {
    if (this.multiProcessorUseCases == null) {
      this.multiProcessorUseCases = new ArrayList<>();
    }
    this.multiProcessorUseCases.add(multiProcessorUseCasesItem);
    return this;
  }

   /**
   * A list of use cases that have been documented that involve this Processor in conjunction with other Processors
   * @return multiProcessorUseCases
  **/
  @Schema(description = "A list of use cases that have been documented that involve this Processor in conjunction with other Processors")
  public List<MultiProcessorUseCase> getMultiProcessorUseCases() {
    return multiProcessorUseCases;
  }

  public void setMultiProcessorUseCases(List<MultiProcessorUseCase> multiProcessorUseCases) {
    this.multiProcessorUseCases = multiProcessorUseCases;
  }

  public ProcessorDefinition primaryNodeOnly(Boolean primaryNodeOnly) {
    this.primaryNodeOnly = primaryNodeOnly;
    return this;
  }

   /**
   * Whether or not this processor should be scheduled only on the primary node in a cluster.
   * @return primaryNodeOnly
  **/
  @Schema(description = "Whether or not this processor should be scheduled only on the primary node in a cluster.")
  public Boolean isPrimaryNodeOnly() {
    return primaryNodeOnly;
  }

  public void setPrimaryNodeOnly(Boolean primaryNodeOnly) {
    this.primaryNodeOnly = primaryNodeOnly;
  }

  public ProcessorDefinition propertyDescriptors(Map<String, PropertyDescriptor> propertyDescriptors) {
    this.propertyDescriptors = propertyDescriptors;
    return this;
  }

  public ProcessorDefinition putPropertyDescriptorsItem(String key, PropertyDescriptor propertyDescriptorsItem) {
    if (this.propertyDescriptors == null) {
      this.propertyDescriptors = new HashMap<>();
    }
    this.propertyDescriptors.put(key, propertyDescriptorsItem);
    return this;
  }

   /**
   * Descriptions of configuration properties applicable to this component.
   * @return propertyDescriptors
  **/
  @Schema(description = "Descriptions of configuration properties applicable to this component.")
  public Map<String, PropertyDescriptor> getPropertyDescriptors() {
    return propertyDescriptors;
  }

  public void setPropertyDescriptors(Map<String, PropertyDescriptor> propertyDescriptors) {
    this.propertyDescriptors = propertyDescriptors;
  }

  public ProcessorDefinition providedApiImplementations(List<DefinedType> providedApiImplementations) {
    this.providedApiImplementations = providedApiImplementations;
    return this;
  }

  public ProcessorDefinition addProvidedApiImplementationsItem(DefinedType providedApiImplementationsItem) {
    if (this.providedApiImplementations == null) {
      this.providedApiImplementations = new ArrayList<>();
    }
    this.providedApiImplementations.add(providedApiImplementationsItem);
    return this;
  }

   /**
   * If this type represents a provider for an interface, this lists the APIs it implements
   * @return providedApiImplementations
  **/
  @Schema(description = "If this type represents a provider for an interface, this lists the APIs it implements")
  public List<DefinedType> getProvidedApiImplementations() {
    return providedApiImplementations;
  }

  public void setProvidedApiImplementations(List<DefinedType> providedApiImplementations) {
    this.providedApiImplementations = providedApiImplementations;
  }

  public ProcessorDefinition readsAttributes(List<Attribute> readsAttributes) {
    this.readsAttributes = readsAttributes;
    return this;
  }

  public ProcessorDefinition addReadsAttributesItem(Attribute readsAttributesItem) {
    if (this.readsAttributes == null) {
      this.readsAttributes = new ArrayList<>();
    }
    this.readsAttributes.add(readsAttributesItem);
    return this;
  }

   /**
   * The FlowFile attributes this processor reads
   * @return readsAttributes
  **/
  @Schema(description = "The FlowFile attributes this processor reads")
  public List<Attribute> getReadsAttributes() {
    return readsAttributes;
  }

  public void setReadsAttributes(List<Attribute> readsAttributes) {
    this.readsAttributes = readsAttributes;
  }

  public ProcessorDefinition restricted(Boolean restricted) {
    this.restricted = restricted;
    return this;
  }

   /**
   * Whether or not the component has a general restriction
   * @return restricted
  **/
  @Schema(description = "Whether or not the component has a general restriction")
  public Boolean isRestricted() {
    return restricted;
  }

  public void setRestricted(Boolean restricted) {
    this.restricted = restricted;
  }

  public ProcessorDefinition restrictedExplanation(String restrictedExplanation) {
    this.restrictedExplanation = restrictedExplanation;
    return this;
  }

   /**
   * An optional description of the general restriction
   * @return restrictedExplanation
  **/
  @Schema(description = "An optional description of the general restriction")
  public String getRestrictedExplanation() {
    return restrictedExplanation;
  }

  public void setRestrictedExplanation(String restrictedExplanation) {
    this.restrictedExplanation = restrictedExplanation;
  }

  public ProcessorDefinition seeAlso(List<String> seeAlso) {
    this.seeAlso = seeAlso;
    return this;
  }

  public ProcessorDefinition addSeeAlsoItem(String seeAlsoItem) {
    if (this.seeAlso == null) {
      this.seeAlso = new ArrayList<>();
    }
    this.seeAlso.add(seeAlsoItem);
    return this;
  }

   /**
   * The names of other component types that may be related
   * @return seeAlso
  **/
  @Schema(description = "The names of other component types that may be related")
  public List<String> getSeeAlso() {
    return seeAlso;
  }

  public void setSeeAlso(List<String> seeAlso) {
    this.seeAlso = seeAlso;
  }

  public ProcessorDefinition sideEffectFree(Boolean sideEffectFree) {
    this.sideEffectFree = sideEffectFree;
    return this;
  }

   /**
   * Whether or not this processor is considered side-effect free. Side-effect free indicate that the processor&#x27;s operations on FlowFiles can be safely repeated across process sessions.
   * @return sideEffectFree
  **/
  @Schema(description = "Whether or not this processor is considered side-effect free. Side-effect free indicate that the processor's operations on FlowFiles can be safely repeated across process sessions.")
  public Boolean isSideEffectFree() {
    return sideEffectFree;
  }

  public void setSideEffectFree(Boolean sideEffectFree) {
    this.sideEffectFree = sideEffectFree;
  }

  public ProcessorDefinition stateful(Stateful stateful) {
    this.stateful = stateful;
    return this;
  }

   /**
   * Get stateful
   * @return stateful
  **/
  @Schema(description = "")
  public Stateful getStateful() {
    return stateful;
  }

  public void setStateful(Stateful stateful) {
    this.stateful = stateful;
  }

  public ProcessorDefinition supportedRelationships(List<Relationship> supportedRelationships) {
    this.supportedRelationships = supportedRelationships;
    return this;
  }

  public ProcessorDefinition addSupportedRelationshipsItem(Relationship supportedRelationshipsItem) {
    if (this.supportedRelationships == null) {
      this.supportedRelationships = new ArrayList<>();
    }
    this.supportedRelationships.add(supportedRelationshipsItem);
    return this;
  }

   /**
   * The supported relationships for this processor.
   * @return supportedRelationships
  **/
  @Schema(description = "The supported relationships for this processor.")
  public List<Relationship> getSupportedRelationships() {
    return supportedRelationships;
  }

  public void setSupportedRelationships(List<Relationship> supportedRelationships) {
    this.supportedRelationships = supportedRelationships;
  }

  public ProcessorDefinition supportedSchedulingStrategies(List<String> supportedSchedulingStrategies) {
    this.supportedSchedulingStrategies = supportedSchedulingStrategies;
    return this;
  }

  public ProcessorDefinition addSupportedSchedulingStrategiesItem(String supportedSchedulingStrategiesItem) {
    if (this.supportedSchedulingStrategies == null) {
      this.supportedSchedulingStrategies = new ArrayList<>();
    }
    this.supportedSchedulingStrategies.add(supportedSchedulingStrategiesItem);
    return this;
  }

   /**
   * The supported scheduling strategies, such as TIME_DRIVER, CRON, or EVENT_DRIVEN.
   * @return supportedSchedulingStrategies
  **/
  @Schema(description = "The supported scheduling strategies, such as TIME_DRIVER, CRON, or EVENT_DRIVEN.")
  public List<String> getSupportedSchedulingStrategies() {
    return supportedSchedulingStrategies;
  }

  public void setSupportedSchedulingStrategies(List<String> supportedSchedulingStrategies) {
    this.supportedSchedulingStrategies = supportedSchedulingStrategies;
  }

  public ProcessorDefinition supportsBatching(Boolean supportsBatching) {
    this.supportsBatching = supportsBatching;
    return this;
  }

   /**
   * Whether or not this processor supports batching. If a Processor uses this annotation, it allows the Framework to batch calls to session commits, as well as allowing the Framework to return the same session multiple times.
   * @return supportsBatching
  **/
  @Schema(description = "Whether or not this processor supports batching. If a Processor uses this annotation, it allows the Framework to batch calls to session commits, as well as allowing the Framework to return the same session multiple times.")
  public Boolean isSupportsBatching() {
    return supportsBatching;
  }

  public void setSupportsBatching(Boolean supportsBatching) {
    this.supportsBatching = supportsBatching;
  }

  public ProcessorDefinition supportsDynamicProperties(Boolean supportsDynamicProperties) {
    this.supportsDynamicProperties = supportsDynamicProperties;
    return this;
  }

   /**
   * Whether or not this component makes use of dynamic (user-set) properties.
   * @return supportsDynamicProperties
  **/
  @Schema(description = "Whether or not this component makes use of dynamic (user-set) properties.")
  public Boolean isSupportsDynamicProperties() {
    return supportsDynamicProperties;
  }

  public void setSupportsDynamicProperties(Boolean supportsDynamicProperties) {
    this.supportsDynamicProperties = supportsDynamicProperties;
  }

  public ProcessorDefinition supportsDynamicRelationships(Boolean supportsDynamicRelationships) {
    this.supportsDynamicRelationships = supportsDynamicRelationships;
    return this;
  }

   /**
   * Whether or not this processor supports dynamic relationships.
   * @return supportsDynamicRelationships
  **/
  @Schema(description = "Whether or not this processor supports dynamic relationships.")
  public Boolean isSupportsDynamicRelationships() {
    return supportsDynamicRelationships;
  }

  public void setSupportsDynamicRelationships(Boolean supportsDynamicRelationships) {
    this.supportsDynamicRelationships = supportsDynamicRelationships;
  }

  public ProcessorDefinition supportsSensitiveDynamicProperties(Boolean supportsSensitiveDynamicProperties) {
    this.supportsSensitiveDynamicProperties = supportsSensitiveDynamicProperties;
    return this;
  }

   /**
   * Whether or not this component makes use of sensitive dynamic (user-set) properties.
   * @return supportsSensitiveDynamicProperties
  **/
  @Schema(description = "Whether or not this component makes use of sensitive dynamic (user-set) properties.")
  public Boolean isSupportsSensitiveDynamicProperties() {
    return supportsSensitiveDynamicProperties;
  }

  public void setSupportsSensitiveDynamicProperties(Boolean supportsSensitiveDynamicProperties) {
    this.supportsSensitiveDynamicProperties = supportsSensitiveDynamicProperties;
  }

  public ProcessorDefinition systemResourceConsiderations(List<SystemResourceConsideration> systemResourceConsiderations) {
    this.systemResourceConsiderations = systemResourceConsiderations;
    return this;
  }

  public ProcessorDefinition addSystemResourceConsiderationsItem(SystemResourceConsideration systemResourceConsiderationsItem) {
    if (this.systemResourceConsiderations == null) {
      this.systemResourceConsiderations = new ArrayList<>();
    }
    this.systemResourceConsiderations.add(systemResourceConsiderationsItem);
    return this;
  }

   /**
   * The system resource considerations for the given component
   * @return systemResourceConsiderations
  **/
  @Schema(description = "The system resource considerations for the given component")
  public List<SystemResourceConsideration> getSystemResourceConsiderations() {
    return systemResourceConsiderations;
  }

  public void setSystemResourceConsiderations(List<SystemResourceConsideration> systemResourceConsiderations) {
    this.systemResourceConsiderations = systemResourceConsiderations;
  }

  public ProcessorDefinition tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public ProcessorDefinition addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<>();
    }
    this.tags.add(tagsItem);
    return this;
  }

   /**
   * The tags associated with this type
   * @return tags
  **/
  @Schema(description = "The tags associated with this type")
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }

  public ProcessorDefinition triggerSerially(Boolean triggerSerially) {
    this.triggerSerially = triggerSerially;
    return this;
  }

   /**
   * Whether or not this processor should be triggered serially (i.e. no concurrent execution).
   * @return triggerSerially
  **/
  @Schema(description = "Whether or not this processor should be triggered serially (i.e. no concurrent execution).")
  public Boolean isTriggerSerially() {
    return triggerSerially;
  }

  public void setTriggerSerially(Boolean triggerSerially) {
    this.triggerSerially = triggerSerially;
  }

  public ProcessorDefinition triggerWhenAnyDestinationAvailable(Boolean triggerWhenAnyDestinationAvailable) {
    this.triggerWhenAnyDestinationAvailable = triggerWhenAnyDestinationAvailable;
    return this;
  }

   /**
   * Whether or not this processor should be triggered when any destination queue has room.
   * @return triggerWhenAnyDestinationAvailable
  **/
  @Schema(description = "Whether or not this processor should be triggered when any destination queue has room.")
  public Boolean isTriggerWhenAnyDestinationAvailable() {
    return triggerWhenAnyDestinationAvailable;
  }

  public void setTriggerWhenAnyDestinationAvailable(Boolean triggerWhenAnyDestinationAvailable) {
    this.triggerWhenAnyDestinationAvailable = triggerWhenAnyDestinationAvailable;
  }

  public ProcessorDefinition triggerWhenEmpty(Boolean triggerWhenEmpty) {
    this.triggerWhenEmpty = triggerWhenEmpty;
    return this;
  }

   /**
   * Whether or not this processor should be triggered when incoming queues are empty.
   * @return triggerWhenEmpty
  **/
  @Schema(description = "Whether or not this processor should be triggered when incoming queues are empty.")
  public Boolean isTriggerWhenEmpty() {
    return triggerWhenEmpty;
  }

  public void setTriggerWhenEmpty(Boolean triggerWhenEmpty) {
    this.triggerWhenEmpty = triggerWhenEmpty;
  }

  public ProcessorDefinition type(String type) {
    this.type = type;
    return this;
  }

   /**
   * The fully-qualified class type
   * @return type
  **/
  @Schema(description = "The fully-qualified class type")
  public String getType() {
    return type;
  }

  public void setType(String type) {
    this.type = type;
  }

  public ProcessorDefinition typeDescription(String typeDescription) {
    this.typeDescription = typeDescription;
    return this;
  }

   /**
   * The description of the type.
   * @return typeDescription
  **/
  @Schema(description = "The description of the type.")
  public String getTypeDescription() {
    return typeDescription;
  }

  public void setTypeDescription(String typeDescription) {
    this.typeDescription = typeDescription;
  }

  public ProcessorDefinition useCases(List<UseCase> useCases) {
    this.useCases = useCases;
    return this;
  }

  public ProcessorDefinition addUseCasesItem(UseCase useCasesItem) {
    if (this.useCases == null) {
      this.useCases = new ArrayList<>();
    }
    this.useCases.add(useCasesItem);
    return this;
  }

   /**
   * A list of use cases that have been documented for this Processor
   * @return useCases
  **/
  @Schema(description = "A list of use cases that have been documented for this Processor")
  public List<UseCase> getUseCases() {
    return useCases;
  }

  public void setUseCases(List<UseCase> useCases) {
    this.useCases = useCases;
  }

  public ProcessorDefinition version(String version) {
    this.version = version;
    return this;
  }

   /**
   * The version of the bundle that provides the referenced type.
   * @return version
  **/
  @Schema(description = "The version of the bundle that provides the referenced type.")
  public String getVersion() {
    return version;
  }

  public void setVersion(String version) {
    this.version = version;
  }

  public ProcessorDefinition writesAttributes(List<Attribute> writesAttributes) {
    this.writesAttributes = writesAttributes;
    return this;
  }

  public ProcessorDefinition addWritesAttributesItem(Attribute writesAttributesItem) {
    if (this.writesAttributes == null) {
      this.writesAttributes = new ArrayList<>();
    }
    this.writesAttributes.add(writesAttributesItem);
    return this;
  }

   /**
   * The FlowFile attributes this processor writes/updates
   * @return writesAttributes
  **/
  @Schema(description = "The FlowFile attributes this processor writes/updates")
  public List<Attribute> getWritesAttributes() {
    return writesAttributes;
  }

  public void setWritesAttributes(List<Attribute> writesAttributes) {
    this.writesAttributes = writesAttributes;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ProcessorDefinition processorDefinition = (ProcessorDefinition) o;
    return Objects.equals(this.additionalDetails, processorDefinition.additionalDetails) &&
        Objects.equals(this.artifact, processorDefinition.artifact) &&
        Objects.equals(this.buildInfo, processorDefinition.buildInfo) &&
        Objects.equals(this.defaultBulletinLevel, processorDefinition.defaultBulletinLevel) &&
        Objects.equals(this.defaultConcurrentTasksBySchedulingStrategy, processorDefinition.defaultConcurrentTasksBySchedulingStrategy) &&
        Objects.equals(this.defaultPenaltyDuration, processorDefinition.defaultPenaltyDuration) &&
        Objects.equals(this.defaultSchedulingPeriodBySchedulingStrategy, processorDefinition.defaultSchedulingPeriodBySchedulingStrategy) &&
        Objects.equals(this.defaultSchedulingStrategy, processorDefinition.defaultSchedulingStrategy) &&
        Objects.equals(this.defaultYieldDuration, processorDefinition.defaultYieldDuration) &&
        Objects.equals(this.deprecated, processorDefinition.deprecated) &&
        Objects.equals(this.deprecationAlternatives, processorDefinition.deprecationAlternatives) &&
        Objects.equals(this.deprecationReason, processorDefinition.deprecationReason) &&
        Objects.equals(this.dynamicProperties, processorDefinition.dynamicProperties) &&
        Objects.equals(this.dynamicRelationship, processorDefinition.dynamicRelationship) &&
        Objects.equals(this.explicitRestrictions, processorDefinition.explicitRestrictions) &&
        Objects.equals(this.group, processorDefinition.group) &&
        Objects.equals(this.inputRequirement, processorDefinition.inputRequirement) &&
        Objects.equals(this.multiProcessorUseCases, processorDefinition.multiProcessorUseCases) &&
        Objects.equals(this.primaryNodeOnly, processorDefinition.primaryNodeOnly) &&
        Objects.equals(this.propertyDescriptors, processorDefinition.propertyDescriptors) &&
        Objects.equals(this.providedApiImplementations, processorDefinition.providedApiImplementations) &&
        Objects.equals(this.readsAttributes, processorDefinition.readsAttributes) &&
        Objects.equals(this.restricted, processorDefinition.restricted) &&
        Objects.equals(this.restrictedExplanation, processorDefinition.restrictedExplanation) &&
        Objects.equals(this.seeAlso, processorDefinition.seeAlso) &&
        Objects.equals(this.sideEffectFree, processorDefinition.sideEffectFree) &&
        Objects.equals(this.stateful, processorDefinition.stateful) &&
        Objects.equals(this.supportedRelationships, processorDefinition.supportedRelationships) &&
        Objects.equals(this.supportedSchedulingStrategies, processorDefinition.supportedSchedulingStrategies) &&
        Objects.equals(this.supportsBatching, processorDefinition.supportsBatching) &&
        Objects.equals(this.supportsDynamicProperties, processorDefinition.supportsDynamicProperties) &&
        Objects.equals(this.supportsDynamicRelationships, processorDefinition.supportsDynamicRelationships) &&
        Objects.equals(this.supportsSensitiveDynamicProperties, processorDefinition.supportsSensitiveDynamicProperties) &&
        Objects.equals(this.systemResourceConsiderations, processorDefinition.systemResourceConsiderations) &&
        Objects.equals(this.tags, processorDefinition.tags) &&
        Objects.equals(this.triggerSerially, processorDefinition.triggerSerially) &&
        Objects.equals(this.triggerWhenAnyDestinationAvailable, processorDefinition.triggerWhenAnyDestinationAvailable) &&
        Objects.equals(this.triggerWhenEmpty, processorDefinition.triggerWhenEmpty) &&
        Objects.equals(this.type, processorDefinition.type) &&
        Objects.equals(this.typeDescription, processorDefinition.typeDescription) &&
        Objects.equals(this.useCases, processorDefinition.useCases) &&
        Objects.equals(this.version, processorDefinition.version) &&
        Objects.equals(this.writesAttributes, processorDefinition.writesAttributes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(additionalDetails, artifact, buildInfo, defaultBulletinLevel, defaultConcurrentTasksBySchedulingStrategy, defaultPenaltyDuration, defaultSchedulingPeriodBySchedulingStrategy, defaultSchedulingStrategy, defaultYieldDuration, deprecated, deprecationAlternatives, deprecationReason, dynamicProperties, dynamicRelationship, explicitRestrictions, group, inputRequirement, multiProcessorUseCases, primaryNodeOnly, propertyDescriptors, providedApiImplementations, readsAttributes, restricted, restrictedExplanation, seeAlso, sideEffectFree, stateful, supportedRelationships, supportedSchedulingStrategies, supportsBatching, supportsDynamicProperties, supportsDynamicRelationships, supportsSensitiveDynamicProperties, systemResourceConsiderations, tags, triggerSerially, triggerWhenAnyDestinationAvailable, triggerWhenEmpty, type, typeDescription, useCases, version, writesAttributes);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ProcessorDefinition {\n");
    
    sb.append("    additionalDetails: ").append(toIndentedString(additionalDetails)).append("\n");
    sb.append("    artifact: ").append(toIndentedString(artifact)).append("\n");
    sb.append("    buildInfo: ").append(toIndentedString(buildInfo)).append("\n");
    sb.append("    defaultBulletinLevel: ").append(toIndentedString(defaultBulletinLevel)).append("\n");
    sb.append("    defaultConcurrentTasksBySchedulingStrategy: ").append(toIndentedString(defaultConcurrentTasksBySchedulingStrategy)).append("\n");
    sb.append("    defaultPenaltyDuration: ").append(toIndentedString(defaultPenaltyDuration)).append("\n");
    sb.append("    defaultSchedulingPeriodBySchedulingStrategy: ").append(toIndentedString(defaultSchedulingPeriodBySchedulingStrategy)).append("\n");
    sb.append("    defaultSchedulingStrategy: ").append(toIndentedString(defaultSchedulingStrategy)).append("\n");
    sb.append("    defaultYieldDuration: ").append(toIndentedString(defaultYieldDuration)).append("\n");
    sb.append("    deprecated: ").append(toIndentedString(deprecated)).append("\n");
    sb.append("    deprecationAlternatives: ").append(toIndentedString(deprecationAlternatives)).append("\n");
    sb.append("    deprecationReason: ").append(toIndentedString(deprecationReason)).append("\n");
    sb.append("    dynamicProperties: ").append(toIndentedString(dynamicProperties)).append("\n");
    sb.append("    dynamicRelationship: ").append(toIndentedString(dynamicRelationship)).append("\n");
    sb.append("    explicitRestrictions: ").append(toIndentedString(explicitRestrictions)).append("\n");
    sb.append("    group: ").append(toIndentedString(group)).append("\n");
    sb.append("    inputRequirement: ").append(toIndentedString(inputRequirement)).append("\n");
    sb.append("    multiProcessorUseCases: ").append(toIndentedString(multiProcessorUseCases)).append("\n");
    sb.append("    primaryNodeOnly: ").append(toIndentedString(primaryNodeOnly)).append("\n");
    sb.append("    propertyDescriptors: ").append(toIndentedString(propertyDescriptors)).append("\n");
    sb.append("    providedApiImplementations: ").append(toIndentedString(providedApiImplementations)).append("\n");
    sb.append("    readsAttributes: ").append(toIndentedString(readsAttributes)).append("\n");
    sb.append("    restricted: ").append(toIndentedString(restricted)).append("\n");
    sb.append("    restrictedExplanation: ").append(toIndentedString(restrictedExplanation)).append("\n");
    sb.append("    seeAlso: ").append(toIndentedString(seeAlso)).append("\n");
    sb.append("    sideEffectFree: ").append(toIndentedString(sideEffectFree)).append("\n");
    sb.append("    stateful: ").append(toIndentedString(stateful)).append("\n");
    sb.append("    supportedRelationships: ").append(toIndentedString(supportedRelationships)).append("\n");
    sb.append("    supportedSchedulingStrategies: ").append(toIndentedString(supportedSchedulingStrategies)).append("\n");
    sb.append("    supportsBatching: ").append(toIndentedString(supportsBatching)).append("\n");
    sb.append("    supportsDynamicProperties: ").append(toIndentedString(supportsDynamicProperties)).append("\n");
    sb.append("    supportsDynamicRelationships: ").append(toIndentedString(supportsDynamicRelationships)).append("\n");
    sb.append("    supportsSensitiveDynamicProperties: ").append(toIndentedString(supportsSensitiveDynamicProperties)).append("\n");
    sb.append("    systemResourceConsiderations: ").append(toIndentedString(systemResourceConsiderations)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("    triggerSerially: ").append(toIndentedString(triggerSerially)).append("\n");
    sb.append("    triggerWhenAnyDestinationAvailable: ").append(toIndentedString(triggerWhenAnyDestinationAvailable)).append("\n");
    sb.append("    triggerWhenEmpty: ").append(toIndentedString(triggerWhenEmpty)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    typeDescription: ").append(toIndentedString(typeDescription)).append("\n");
    sb.append("    useCases: ").append(toIndentedString(useCases)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("    writesAttributes: ").append(toIndentedString(writesAttributes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
