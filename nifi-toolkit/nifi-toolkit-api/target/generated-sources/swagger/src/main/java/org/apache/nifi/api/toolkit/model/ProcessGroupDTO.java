/*
 * Apache NiFi REST API
 * REST API definition for Apache NiFi web services
 *
 * OpenAPI spec version: 2.4.0
 * Contact: dev@nifi.apache.org
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package org.apache.nifi.api.toolkit.model;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.v3.oas.annotations.media.Schema;
import org.apache.nifi.api.toolkit.model.FlowSnippetDTO;
import org.apache.nifi.api.toolkit.model.ParameterContextReferenceEntity;
import org.apache.nifi.api.toolkit.model.PositionDTO;
import org.apache.nifi.api.toolkit.model.VersionControlInformationDTO;
/**
 * ProcessGroupDTO
 */

@javax.annotation.Generated(value = "io.swagger.codegen.v3.generators.java.JavaClientCodegen", date = "2025-09-03T13:15:23.252321740+05:30[Asia/Kolkata]")

public class ProcessGroupDTO {
  @JsonProperty("activeRemotePortCount")
  private Integer activeRemotePortCount = null;

  @JsonProperty("comments")
  private String comments = null;

  @JsonProperty("contents")
  private FlowSnippetDTO contents = null;

  @JsonProperty("defaultBackPressureDataSizeThreshold")
  private String defaultBackPressureDataSizeThreshold = null;

  @JsonProperty("defaultBackPressureObjectThreshold")
  private Long defaultBackPressureObjectThreshold = null;

  @JsonProperty("defaultFlowFileExpiration")
  private String defaultFlowFileExpiration = null;

  @JsonProperty("disabledCount")
  private Integer disabledCount = null;

  /**
   * The Execution Engine that should be used to run the flow represented by this Process Group.
   */
  public enum ExecutionEngineEnum {
    STATELESS("STATELESS"),
    STANDARD("STANDARD"),
    INHERITED("INHERITED");

    private String value;

    ExecutionEngineEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static ExecutionEngineEnum fromValue(String input) {
      for (ExecutionEngineEnum b : ExecutionEngineEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("executionEngine")
  private ExecutionEngineEnum executionEngine = null;

  /**
   * The FlowFile Concurrency for this Process Group.
   */
  public enum FlowfileConcurrencyEnum {
    UNBOUNDED("UNBOUNDED"),
    SINGLE_FLOWFILE_PER_NODE("SINGLE_FLOWFILE_PER_NODE"),
    SINGLE_BATCH_PER_NODE("SINGLE_BATCH_PER_NODE");

    private String value;

    FlowfileConcurrencyEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static FlowfileConcurrencyEnum fromValue(String input) {
      for (FlowfileConcurrencyEnum b : FlowfileConcurrencyEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("flowfileConcurrency")
  private FlowfileConcurrencyEnum flowfileConcurrency = null;

  /**
   * The Outbound Policy that is used for determining how FlowFiles should be transferred out of the Process Group.
   */
  public enum FlowfileOutboundPolicyEnum {
    STREAM_WHEN_AVAILABLE("STREAM_WHEN_AVAILABLE"),
    BATCH_OUTPUT("BATCH_OUTPUT");

    private String value;

    FlowfileOutboundPolicyEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static FlowfileOutboundPolicyEnum fromValue(String input) {
      for (FlowfileOutboundPolicyEnum b : FlowfileOutboundPolicyEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("flowfileOutboundPolicy")
  private FlowfileOutboundPolicyEnum flowfileOutboundPolicy = null;

  @JsonProperty("id")
  private String id = null;

  @JsonProperty("inactiveRemotePortCount")
  private Integer inactiveRemotePortCount = null;

  @JsonProperty("inputPortCount")
  private Integer inputPortCount = null;

  @JsonProperty("invalidCount")
  private Integer invalidCount = null;

  @JsonProperty("localInputPortCount")
  private Integer localInputPortCount = null;

  @JsonProperty("localOutputPortCount")
  private Integer localOutputPortCount = null;

  @JsonProperty("locallyModifiedAndStaleCount")
  private Integer locallyModifiedAndStaleCount = null;

  @JsonProperty("locallyModifiedCount")
  private Integer locallyModifiedCount = null;

  @JsonProperty("logFileSuffix")
  private String logFileSuffix = null;

  @JsonProperty("maxConcurrentTasks")
  private Integer maxConcurrentTasks = null;

  @JsonProperty("name")
  private String name = null;

  @JsonProperty("outputPortCount")
  private Integer outputPortCount = null;

  @JsonProperty("parameterContext")
  private ParameterContextReferenceEntity parameterContext = null;

  @JsonProperty("parentGroupId")
  private String parentGroupId = null;

  @JsonProperty("position")
  private PositionDTO position = null;

  @JsonProperty("publicInputPortCount")
  private Integer publicInputPortCount = null;

  @JsonProperty("publicOutputPortCount")
  private Integer publicOutputPortCount = null;

  @JsonProperty("runningCount")
  private Integer runningCount = null;

  @JsonProperty("staleCount")
  private Integer staleCount = null;

  @JsonProperty("statelessFlowTimeout")
  private String statelessFlowTimeout = null;

  /**
   * If the Process Group is configured to run in using the Stateless Engine, represents the current state. Otherwise, will be STOPPED.
   */
  public enum StatelessGroupScheduledStateEnum {
    STOPPED("STOPPED"),
    RUNNING("RUNNING");

    private String value;

    StatelessGroupScheduledStateEnum(String value) {
      this.value = value;
    }
    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    @JsonCreator
    public static StatelessGroupScheduledStateEnum fromValue(String input) {
      for (StatelessGroupScheduledStateEnum b : StatelessGroupScheduledStateEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }

  }  @JsonProperty("statelessGroupScheduledState")
  private StatelessGroupScheduledStateEnum statelessGroupScheduledState = null;

  @JsonProperty("stoppedCount")
  private Integer stoppedCount = null;

  @JsonProperty("syncFailureCount")
  private Integer syncFailureCount = null;

  @JsonProperty("upToDateCount")
  private Integer upToDateCount = null;

  @JsonProperty("versionControlInformation")
  private VersionControlInformationDTO versionControlInformation = null;

  @JsonProperty("versionedComponentId")
  private String versionedComponentId = null;

  public ProcessGroupDTO activeRemotePortCount(Integer activeRemotePortCount) {
    this.activeRemotePortCount = activeRemotePortCount;
    return this;
  }

   /**
   * The number of active remote ports in the process group.
   * @return activeRemotePortCount
  **/
  @Schema(description = "The number of active remote ports in the process group.")
  public Integer getActiveRemotePortCount() {
    return activeRemotePortCount;
  }

  public void setActiveRemotePortCount(Integer activeRemotePortCount) {
    this.activeRemotePortCount = activeRemotePortCount;
  }

  public ProcessGroupDTO comments(String comments) {
    this.comments = comments;
    return this;
  }

   /**
   * The comments for the process group.
   * @return comments
  **/
  @Schema(description = "The comments for the process group.")
  public String getComments() {
    return comments;
  }

  public void setComments(String comments) {
    this.comments = comments;
  }

  public ProcessGroupDTO contents(FlowSnippetDTO contents) {
    this.contents = contents;
    return this;
  }

   /**
   * Get contents
   * @return contents
  **/
  @Schema(description = "")
  public FlowSnippetDTO getContents() {
    return contents;
  }

  public void setContents(FlowSnippetDTO contents) {
    this.contents = contents;
  }

  public ProcessGroupDTO defaultBackPressureDataSizeThreshold(String defaultBackPressureDataSizeThreshold) {
    this.defaultBackPressureDataSizeThreshold = defaultBackPressureDataSizeThreshold;
    return this;
  }

   /**
   * Default value used in this Process Group for the maximum data size of objects that can be queued before back pressure is applied.
   * @return defaultBackPressureDataSizeThreshold
  **/
  @Schema(description = "Default value used in this Process Group for the maximum data size of objects that can be queued before back pressure is applied.")
  public String getDefaultBackPressureDataSizeThreshold() {
    return defaultBackPressureDataSizeThreshold;
  }

  public void setDefaultBackPressureDataSizeThreshold(String defaultBackPressureDataSizeThreshold) {
    this.defaultBackPressureDataSizeThreshold = defaultBackPressureDataSizeThreshold;
  }

  public ProcessGroupDTO defaultBackPressureObjectThreshold(Long defaultBackPressureObjectThreshold) {
    this.defaultBackPressureObjectThreshold = defaultBackPressureObjectThreshold;
    return this;
  }

   /**
   * Default value used in this Process Group for the maximum number of objects that can be queued before back pressure is applied.
   * @return defaultBackPressureObjectThreshold
  **/
  @Schema(description = "Default value used in this Process Group for the maximum number of objects that can be queued before back pressure is applied.")
  public Long getDefaultBackPressureObjectThreshold() {
    return defaultBackPressureObjectThreshold;
  }

  public void setDefaultBackPressureObjectThreshold(Long defaultBackPressureObjectThreshold) {
    this.defaultBackPressureObjectThreshold = defaultBackPressureObjectThreshold;
  }

  public ProcessGroupDTO defaultFlowFileExpiration(String defaultFlowFileExpiration) {
    this.defaultFlowFileExpiration = defaultFlowFileExpiration;
    return this;
  }

   /**
   * The default FlowFile Expiration for this Process Group.
   * @return defaultFlowFileExpiration
  **/
  @Schema(description = "The default FlowFile Expiration for this Process Group.")
  public String getDefaultFlowFileExpiration() {
    return defaultFlowFileExpiration;
  }

  public void setDefaultFlowFileExpiration(String defaultFlowFileExpiration) {
    this.defaultFlowFileExpiration = defaultFlowFileExpiration;
  }

  public ProcessGroupDTO disabledCount(Integer disabledCount) {
    this.disabledCount = disabledCount;
    return this;
  }

   /**
   * The number of disabled components in the process group.
   * @return disabledCount
  **/
  @Schema(description = "The number of disabled components in the process group.")
  public Integer getDisabledCount() {
    return disabledCount;
  }

  public void setDisabledCount(Integer disabledCount) {
    this.disabledCount = disabledCount;
  }

  public ProcessGroupDTO executionEngine(ExecutionEngineEnum executionEngine) {
    this.executionEngine = executionEngine;
    return this;
  }

   /**
   * The Execution Engine that should be used to run the flow represented by this Process Group.
   * @return executionEngine
  **/
  @Schema(description = "The Execution Engine that should be used to run the flow represented by this Process Group.")
  public ExecutionEngineEnum getExecutionEngine() {
    return executionEngine;
  }

  public void setExecutionEngine(ExecutionEngineEnum executionEngine) {
    this.executionEngine = executionEngine;
  }

  public ProcessGroupDTO flowfileConcurrency(FlowfileConcurrencyEnum flowfileConcurrency) {
    this.flowfileConcurrency = flowfileConcurrency;
    return this;
  }

   /**
   * The FlowFile Concurrency for this Process Group.
   * @return flowfileConcurrency
  **/
  @Schema(description = "The FlowFile Concurrency for this Process Group.")
  public FlowfileConcurrencyEnum getFlowfileConcurrency() {
    return flowfileConcurrency;
  }

  public void setFlowfileConcurrency(FlowfileConcurrencyEnum flowfileConcurrency) {
    this.flowfileConcurrency = flowfileConcurrency;
  }

  public ProcessGroupDTO flowfileOutboundPolicy(FlowfileOutboundPolicyEnum flowfileOutboundPolicy) {
    this.flowfileOutboundPolicy = flowfileOutboundPolicy;
    return this;
  }

   /**
   * The Outbound Policy that is used for determining how FlowFiles should be transferred out of the Process Group.
   * @return flowfileOutboundPolicy
  **/
  @Schema(description = "The Outbound Policy that is used for determining how FlowFiles should be transferred out of the Process Group.")
  public FlowfileOutboundPolicyEnum getFlowfileOutboundPolicy() {
    return flowfileOutboundPolicy;
  }

  public void setFlowfileOutboundPolicy(FlowfileOutboundPolicyEnum flowfileOutboundPolicy) {
    this.flowfileOutboundPolicy = flowfileOutboundPolicy;
  }

  public ProcessGroupDTO id(String id) {
    this.id = id;
    return this;
  }

   /**
   * The id of the component.
   * @return id
  **/
  @Schema(description = "The id of the component.")
  public String getId() {
    return id;
  }

  public void setId(String id) {
    this.id = id;
  }

  public ProcessGroupDTO inactiveRemotePortCount(Integer inactiveRemotePortCount) {
    this.inactiveRemotePortCount = inactiveRemotePortCount;
    return this;
  }

   /**
   * The number of inactive remote ports in the process group.
   * @return inactiveRemotePortCount
  **/
  @Schema(description = "The number of inactive remote ports in the process group.")
  public Integer getInactiveRemotePortCount() {
    return inactiveRemotePortCount;
  }

  public void setInactiveRemotePortCount(Integer inactiveRemotePortCount) {
    this.inactiveRemotePortCount = inactiveRemotePortCount;
  }

   /**
   * The number of input ports in the process group.
   * @return inputPortCount
  **/
  @Schema(description = "The number of input ports in the process group.")
  public Integer getInputPortCount() {
    return inputPortCount;
  }

  public ProcessGroupDTO invalidCount(Integer invalidCount) {
    this.invalidCount = invalidCount;
    return this;
  }

   /**
   * The number of invalid components in the process group.
   * @return invalidCount
  **/
  @Schema(description = "The number of invalid components in the process group.")
  public Integer getInvalidCount() {
    return invalidCount;
  }

  public void setInvalidCount(Integer invalidCount) {
    this.invalidCount = invalidCount;
  }

  public ProcessGroupDTO localInputPortCount(Integer localInputPortCount) {
    this.localInputPortCount = localInputPortCount;
    return this;
  }

   /**
   * The number of local input ports in the process group.
   * @return localInputPortCount
  **/
  @Schema(description = "The number of local input ports in the process group.")
  public Integer getLocalInputPortCount() {
    return localInputPortCount;
  }

  public void setLocalInputPortCount(Integer localInputPortCount) {
    this.localInputPortCount = localInputPortCount;
  }

  public ProcessGroupDTO localOutputPortCount(Integer localOutputPortCount) {
    this.localOutputPortCount = localOutputPortCount;
    return this;
  }

   /**
   * The number of local output ports in the process group.
   * @return localOutputPortCount
  **/
  @Schema(description = "The number of local output ports in the process group.")
  public Integer getLocalOutputPortCount() {
    return localOutputPortCount;
  }

  public void setLocalOutputPortCount(Integer localOutputPortCount) {
    this.localOutputPortCount = localOutputPortCount;
  }

  public ProcessGroupDTO locallyModifiedAndStaleCount(Integer locallyModifiedAndStaleCount) {
    this.locallyModifiedAndStaleCount = locallyModifiedAndStaleCount;
    return this;
  }

   /**
   * The number of locally modified and stale versioned process groups in the process group.
   * @return locallyModifiedAndStaleCount
  **/
  @Schema(description = "The number of locally modified and stale versioned process groups in the process group.")
  public Integer getLocallyModifiedAndStaleCount() {
    return locallyModifiedAndStaleCount;
  }

  public void setLocallyModifiedAndStaleCount(Integer locallyModifiedAndStaleCount) {
    this.locallyModifiedAndStaleCount = locallyModifiedAndStaleCount;
  }

  public ProcessGroupDTO locallyModifiedCount(Integer locallyModifiedCount) {
    this.locallyModifiedCount = locallyModifiedCount;
    return this;
  }

   /**
   * The number of locally modified versioned process groups in the process group.
   * @return locallyModifiedCount
  **/
  @Schema(description = "The number of locally modified versioned process groups in the process group.")
  public Integer getLocallyModifiedCount() {
    return locallyModifiedCount;
  }

  public void setLocallyModifiedCount(Integer locallyModifiedCount) {
    this.locallyModifiedCount = locallyModifiedCount;
  }

  public ProcessGroupDTO logFileSuffix(String logFileSuffix) {
    this.logFileSuffix = logFileSuffix;
    return this;
  }

   /**
   * The log file suffix for this Process Group for dedicated logging.
   * @return logFileSuffix
  **/
  @Schema(description = "The log file suffix for this Process Group for dedicated logging.")
  public String getLogFileSuffix() {
    return logFileSuffix;
  }

  public void setLogFileSuffix(String logFileSuffix) {
    this.logFileSuffix = logFileSuffix;
  }

  public ProcessGroupDTO maxConcurrentTasks(Integer maxConcurrentTasks) {
    this.maxConcurrentTasks = maxConcurrentTasks;
    return this;
  }

   /**
   * The maximum number of concurrent tasks to use when running the flow using the Stateless Engine
   * @return maxConcurrentTasks
  **/
  @Schema(description = "The maximum number of concurrent tasks to use when running the flow using the Stateless Engine")
  public Integer getMaxConcurrentTasks() {
    return maxConcurrentTasks;
  }

  public void setMaxConcurrentTasks(Integer maxConcurrentTasks) {
    this.maxConcurrentTasks = maxConcurrentTasks;
  }

  public ProcessGroupDTO name(String name) {
    this.name = name;
    return this;
  }

   /**
   * The name of the process group.
   * @return name
  **/
  @Schema(description = "The name of the process group.")
  public String getName() {
    return name;
  }

  public void setName(String name) {
    this.name = name;
  }

   /**
   * The number of output ports in the process group.
   * @return outputPortCount
  **/
  @Schema(description = "The number of output ports in the process group.")
  public Integer getOutputPortCount() {
    return outputPortCount;
  }

  public ProcessGroupDTO parameterContext(ParameterContextReferenceEntity parameterContext) {
    this.parameterContext = parameterContext;
    return this;
  }

   /**
   * Get parameterContext
   * @return parameterContext
  **/
  @Schema(description = "")
  public ParameterContextReferenceEntity getParameterContext() {
    return parameterContext;
  }

  public void setParameterContext(ParameterContextReferenceEntity parameterContext) {
    this.parameterContext = parameterContext;
  }

  public ProcessGroupDTO parentGroupId(String parentGroupId) {
    this.parentGroupId = parentGroupId;
    return this;
  }

   /**
   * The id of parent process group of this component if applicable.
   * @return parentGroupId
  **/
  @Schema(description = "The id of parent process group of this component if applicable.")
  public String getParentGroupId() {
    return parentGroupId;
  }

  public void setParentGroupId(String parentGroupId) {
    this.parentGroupId = parentGroupId;
  }

  public ProcessGroupDTO position(PositionDTO position) {
    this.position = position;
    return this;
  }

   /**
   * Get position
   * @return position
  **/
  @Schema(description = "")
  public PositionDTO getPosition() {
    return position;
  }

  public void setPosition(PositionDTO position) {
    this.position = position;
  }

  public ProcessGroupDTO publicInputPortCount(Integer publicInputPortCount) {
    this.publicInputPortCount = publicInputPortCount;
    return this;
  }

   /**
   * The number of public input ports in the process group.
   * @return publicInputPortCount
  **/
  @Schema(description = "The number of public input ports in the process group.")
  public Integer getPublicInputPortCount() {
    return publicInputPortCount;
  }

  public void setPublicInputPortCount(Integer publicInputPortCount) {
    this.publicInputPortCount = publicInputPortCount;
  }

  public ProcessGroupDTO publicOutputPortCount(Integer publicOutputPortCount) {
    this.publicOutputPortCount = publicOutputPortCount;
    return this;
  }

   /**
   * The number of public output ports in the process group.
   * @return publicOutputPortCount
  **/
  @Schema(description = "The number of public output ports in the process group.")
  public Integer getPublicOutputPortCount() {
    return publicOutputPortCount;
  }

  public void setPublicOutputPortCount(Integer publicOutputPortCount) {
    this.publicOutputPortCount = publicOutputPortCount;
  }

  public ProcessGroupDTO runningCount(Integer runningCount) {
    this.runningCount = runningCount;
    return this;
  }

   /**
   * The number of running components in this process group.
   * @return runningCount
  **/
  @Schema(description = "The number of running components in this process group.")
  public Integer getRunningCount() {
    return runningCount;
  }

  public void setRunningCount(Integer runningCount) {
    this.runningCount = runningCount;
  }

  public ProcessGroupDTO staleCount(Integer staleCount) {
    this.staleCount = staleCount;
    return this;
  }

   /**
   * The number of stale versioned process groups in the process group.
   * @return staleCount
  **/
  @Schema(description = "The number of stale versioned process groups in the process group.")
  public Integer getStaleCount() {
    return staleCount;
  }

  public void setStaleCount(Integer staleCount) {
    this.staleCount = staleCount;
  }

  public ProcessGroupDTO statelessFlowTimeout(String statelessFlowTimeout) {
    this.statelessFlowTimeout = statelessFlowTimeout;
    return this;
  }

   /**
   * The maximum amount of time that the flow can be run using the Stateless Engine before the flow times out
   * @return statelessFlowTimeout
  **/
  @Schema(description = "The maximum amount of time that the flow can be run using the Stateless Engine before the flow times out")
  public String getStatelessFlowTimeout() {
    return statelessFlowTimeout;
  }

  public void setStatelessFlowTimeout(String statelessFlowTimeout) {
    this.statelessFlowTimeout = statelessFlowTimeout;
  }

  public ProcessGroupDTO statelessGroupScheduledState(StatelessGroupScheduledStateEnum statelessGroupScheduledState) {
    this.statelessGroupScheduledState = statelessGroupScheduledState;
    return this;
  }

   /**
   * If the Process Group is configured to run in using the Stateless Engine, represents the current state. Otherwise, will be STOPPED.
   * @return statelessGroupScheduledState
  **/
  @Schema(description = "If the Process Group is configured to run in using the Stateless Engine, represents the current state. Otherwise, will be STOPPED.")
  public StatelessGroupScheduledStateEnum getStatelessGroupScheduledState() {
    return statelessGroupScheduledState;
  }

  public void setStatelessGroupScheduledState(StatelessGroupScheduledStateEnum statelessGroupScheduledState) {
    this.statelessGroupScheduledState = statelessGroupScheduledState;
  }

  public ProcessGroupDTO stoppedCount(Integer stoppedCount) {
    this.stoppedCount = stoppedCount;
    return this;
  }

   /**
   * The number of stopped components in the process group.
   * @return stoppedCount
  **/
  @Schema(description = "The number of stopped components in the process group.")
  public Integer getStoppedCount() {
    return stoppedCount;
  }

  public void setStoppedCount(Integer stoppedCount) {
    this.stoppedCount = stoppedCount;
  }

  public ProcessGroupDTO syncFailureCount(Integer syncFailureCount) {
    this.syncFailureCount = syncFailureCount;
    return this;
  }

   /**
   * The number of versioned process groups in the process group that are unable to sync to a registry.
   * @return syncFailureCount
  **/
  @Schema(description = "The number of versioned process groups in the process group that are unable to sync to a registry.")
  public Integer getSyncFailureCount() {
    return syncFailureCount;
  }

  public void setSyncFailureCount(Integer syncFailureCount) {
    this.syncFailureCount = syncFailureCount;
  }

  public ProcessGroupDTO upToDateCount(Integer upToDateCount) {
    this.upToDateCount = upToDateCount;
    return this;
  }

   /**
   * The number of up to date versioned process groups in the process group.
   * @return upToDateCount
  **/
  @Schema(description = "The number of up to date versioned process groups in the process group.")
  public Integer getUpToDateCount() {
    return upToDateCount;
  }

  public void setUpToDateCount(Integer upToDateCount) {
    this.upToDateCount = upToDateCount;
  }

  public ProcessGroupDTO versionControlInformation(VersionControlInformationDTO versionControlInformation) {
    this.versionControlInformation = versionControlInformation;
    return this;
  }

   /**
   * Get versionControlInformation
   * @return versionControlInformation
  **/
  @Schema(description = "")
  public VersionControlInformationDTO getVersionControlInformation() {
    return versionControlInformation;
  }

  public void setVersionControlInformation(VersionControlInformationDTO versionControlInformation) {
    this.versionControlInformation = versionControlInformation;
  }

  public ProcessGroupDTO versionedComponentId(String versionedComponentId) {
    this.versionedComponentId = versionedComponentId;
    return this;
  }

   /**
   * The ID of the corresponding component that is under version control
   * @return versionedComponentId
  **/
  @Schema(description = "The ID of the corresponding component that is under version control")
  public String getVersionedComponentId() {
    return versionedComponentId;
  }

  public void setVersionedComponentId(String versionedComponentId) {
    this.versionedComponentId = versionedComponentId;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ProcessGroupDTO processGroupDTO = (ProcessGroupDTO) o;
    return Objects.equals(this.activeRemotePortCount, processGroupDTO.activeRemotePortCount) &&
        Objects.equals(this.comments, processGroupDTO.comments) &&
        Objects.equals(this.contents, processGroupDTO.contents) &&
        Objects.equals(this.defaultBackPressureDataSizeThreshold, processGroupDTO.defaultBackPressureDataSizeThreshold) &&
        Objects.equals(this.defaultBackPressureObjectThreshold, processGroupDTO.defaultBackPressureObjectThreshold) &&
        Objects.equals(this.defaultFlowFileExpiration, processGroupDTO.defaultFlowFileExpiration) &&
        Objects.equals(this.disabledCount, processGroupDTO.disabledCount) &&
        Objects.equals(this.executionEngine, processGroupDTO.executionEngine) &&
        Objects.equals(this.flowfileConcurrency, processGroupDTO.flowfileConcurrency) &&
        Objects.equals(this.flowfileOutboundPolicy, processGroupDTO.flowfileOutboundPolicy) &&
        Objects.equals(this.id, processGroupDTO.id) &&
        Objects.equals(this.inactiveRemotePortCount, processGroupDTO.inactiveRemotePortCount) &&
        Objects.equals(this.inputPortCount, processGroupDTO.inputPortCount) &&
        Objects.equals(this.invalidCount, processGroupDTO.invalidCount) &&
        Objects.equals(this.localInputPortCount, processGroupDTO.localInputPortCount) &&
        Objects.equals(this.localOutputPortCount, processGroupDTO.localOutputPortCount) &&
        Objects.equals(this.locallyModifiedAndStaleCount, processGroupDTO.locallyModifiedAndStaleCount) &&
        Objects.equals(this.locallyModifiedCount, processGroupDTO.locallyModifiedCount) &&
        Objects.equals(this.logFileSuffix, processGroupDTO.logFileSuffix) &&
        Objects.equals(this.maxConcurrentTasks, processGroupDTO.maxConcurrentTasks) &&
        Objects.equals(this.name, processGroupDTO.name) &&
        Objects.equals(this.outputPortCount, processGroupDTO.outputPortCount) &&
        Objects.equals(this.parameterContext, processGroupDTO.parameterContext) &&
        Objects.equals(this.parentGroupId, processGroupDTO.parentGroupId) &&
        Objects.equals(this.position, processGroupDTO.position) &&
        Objects.equals(this.publicInputPortCount, processGroupDTO.publicInputPortCount) &&
        Objects.equals(this.publicOutputPortCount, processGroupDTO.publicOutputPortCount) &&
        Objects.equals(this.runningCount, processGroupDTO.runningCount) &&
        Objects.equals(this.staleCount, processGroupDTO.staleCount) &&
        Objects.equals(this.statelessFlowTimeout, processGroupDTO.statelessFlowTimeout) &&
        Objects.equals(this.statelessGroupScheduledState, processGroupDTO.statelessGroupScheduledState) &&
        Objects.equals(this.stoppedCount, processGroupDTO.stoppedCount) &&
        Objects.equals(this.syncFailureCount, processGroupDTO.syncFailureCount) &&
        Objects.equals(this.upToDateCount, processGroupDTO.upToDateCount) &&
        Objects.equals(this.versionControlInformation, processGroupDTO.versionControlInformation) &&
        Objects.equals(this.versionedComponentId, processGroupDTO.versionedComponentId);
  }

  @Override
  public int hashCode() {
    return Objects.hash(activeRemotePortCount, comments, contents, defaultBackPressureDataSizeThreshold, defaultBackPressureObjectThreshold, defaultFlowFileExpiration, disabledCount, executionEngine, flowfileConcurrency, flowfileOutboundPolicy, id, inactiveRemotePortCount, inputPortCount, invalidCount, localInputPortCount, localOutputPortCount, locallyModifiedAndStaleCount, locallyModifiedCount, logFileSuffix, maxConcurrentTasks, name, outputPortCount, parameterContext, parentGroupId, position, publicInputPortCount, publicOutputPortCount, runningCount, staleCount, statelessFlowTimeout, statelessGroupScheduledState, stoppedCount, syncFailureCount, upToDateCount, versionControlInformation, versionedComponentId);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ProcessGroupDTO {\n");
    
    sb.append("    activeRemotePortCount: ").append(toIndentedString(activeRemotePortCount)).append("\n");
    sb.append("    comments: ").append(toIndentedString(comments)).append("\n");
    sb.append("    contents: ").append(toIndentedString(contents)).append("\n");
    sb.append("    defaultBackPressureDataSizeThreshold: ").append(toIndentedString(defaultBackPressureDataSizeThreshold)).append("\n");
    sb.append("    defaultBackPressureObjectThreshold: ").append(toIndentedString(defaultBackPressureObjectThreshold)).append("\n");
    sb.append("    defaultFlowFileExpiration: ").append(toIndentedString(defaultFlowFileExpiration)).append("\n");
    sb.append("    disabledCount: ").append(toIndentedString(disabledCount)).append("\n");
    sb.append("    executionEngine: ").append(toIndentedString(executionEngine)).append("\n");
    sb.append("    flowfileConcurrency: ").append(toIndentedString(flowfileConcurrency)).append("\n");
    sb.append("    flowfileOutboundPolicy: ").append(toIndentedString(flowfileOutboundPolicy)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    inactiveRemotePortCount: ").append(toIndentedString(inactiveRemotePortCount)).append("\n");
    sb.append("    inputPortCount: ").append(toIndentedString(inputPortCount)).append("\n");
    sb.append("    invalidCount: ").append(toIndentedString(invalidCount)).append("\n");
    sb.append("    localInputPortCount: ").append(toIndentedString(localInputPortCount)).append("\n");
    sb.append("    localOutputPortCount: ").append(toIndentedString(localOutputPortCount)).append("\n");
    sb.append("    locallyModifiedAndStaleCount: ").append(toIndentedString(locallyModifiedAndStaleCount)).append("\n");
    sb.append("    locallyModifiedCount: ").append(toIndentedString(locallyModifiedCount)).append("\n");
    sb.append("    logFileSuffix: ").append(toIndentedString(logFileSuffix)).append("\n");
    sb.append("    maxConcurrentTasks: ").append(toIndentedString(maxConcurrentTasks)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    outputPortCount: ").append(toIndentedString(outputPortCount)).append("\n");
    sb.append("    parameterContext: ").append(toIndentedString(parameterContext)).append("\n");
    sb.append("    parentGroupId: ").append(toIndentedString(parentGroupId)).append("\n");
    sb.append("    position: ").append(toIndentedString(position)).append("\n");
    sb.append("    publicInputPortCount: ").append(toIndentedString(publicInputPortCount)).append("\n");
    sb.append("    publicOutputPortCount: ").append(toIndentedString(publicOutputPortCount)).append("\n");
    sb.append("    runningCount: ").append(toIndentedString(runningCount)).append("\n");
    sb.append("    staleCount: ").append(toIndentedString(staleCount)).append("\n");
    sb.append("    statelessFlowTimeout: ").append(toIndentedString(statelessFlowTimeout)).append("\n");
    sb.append("    statelessGroupScheduledState: ").append(toIndentedString(statelessGroupScheduledState)).append("\n");
    sb.append("    stoppedCount: ").append(toIndentedString(stoppedCount)).append("\n");
    sb.append("    syncFailureCount: ").append(toIndentedString(syncFailureCount)).append("\n");
    sb.append("    upToDateCount: ").append(toIndentedString(upToDateCount)).append("\n");
    sb.append("    versionControlInformation: ").append(toIndentedString(versionControlInformation)).append("\n");
    sb.append("    versionedComponentId: ").append(toIndentedString(versionedComponentId)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
